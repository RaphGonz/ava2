---
phase: 04-secretary-skills
plan: "03"
type: execute
wave: 2
depends_on: ["04-01", "04-02"]
files_modified:
  - backend/app/services/skills/calendar_skill.py
autonomous: true
requirements: [SECR-01, SECR-02]

must_haves:
  truths:
    - "User can say 'add team standup Tuesday at 3pm' and the bot adds it to Google Calendar and replies 'Added: Team standup · Tue · 3:00pm'"
    - "User can ask 'what's on my calendar?' and the bot lists upcoming events as bullet points"
    - "When no tokens exist, bot replies with a link to connect Google Calendar instead of failing"
    - "When a calendar conflict exists, bot warns and asks for confirmation before adding"
    - "When a meeting title or time is missing, bot asks for the single missing piece"
    - "When Google Calendar API errors, bot replies with a plain error message — no stack traces"
    - "All Google API calls run in asyncio.to_thread — FastAPI event loop is never blocked"
  artifacts:
    - path: "backend/app/services/skills/calendar_skill.py"
      provides: "CalendarSkill class with handle() implementing SECR-01 and SECR-02"
      contains: "class CalendarSkill"
      exports: ["CalendarSkill"]
  key_links:
    - from: "backend/app/services/skills/calendar_skill.py"
      to: "backend/app/services/google_auth/flow.py"
      via: "get_credentials_for_user() to load and refresh tokens"
      pattern: "get_credentials_for_user"
    - from: "backend/app/services/skills/calendar_skill.py"
      to: "googleapiclient.discovery.build"
      via: "asyncio.to_thread wrapping synchronous build() call"
      pattern: "asyncio\\.to_thread"
    - from: "backend/app/services/skills/calendar_skill.py"
      to: "dateparser.parse"
      via: "parse_user_date() helper with FR+EN, PREFER_DATES_FROM=future"
      pattern: "dateparser\\.parse"
    - from: "backend/app/services/skills/calendar_skill.py"
      to: "backend/app/services/skills/registry.py"
      via: "CalendarSkill registered on module import"
      pattern: "register\\("
---

<objective>
Build the calendar skill that handles SECR-01 (add meeting) and SECR-02 (view schedule), wired to Google Calendar API via the OAuth infrastructure from Plan 02.

Purpose: Users must be able to manage their Google Calendar via WhatsApp chat. This plan implements the CalendarSkill class satisfying both calendar intents, with conflict detection, missing-field prompting, multilingual date parsing (FR+EN), and graceful error handling.

Output: backend/app/services/skills/calendar_skill.py — a CalendarSkill implementing the Skill Protocol and registered in the skill registry.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-secretary-skills/04-CONTEXT.md
@.planning/phases/04-secretary-skills/04-RESEARCH.md
@.planning/phases/04-secretary-skills/04-01-SUMMARY.md
@.planning/phases/04-secretary-skills/04-02-SUMMARY.md
@backend/app/services/skills/registry.py
@backend/app/services/google_auth/flow.py
@backend/app/services/google_auth/token_store.py
@backend/app/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement CalendarSkill with calendar_add and calendar_view handlers</name>
  <files>
    backend/app/services/skills/calendar_skill.py
  </files>
  <action>
Create backend/app/services/skills/calendar_skill.py implementing the full CalendarSkill.

**Key design constraints from CONTEXT.md (LOCKED DECISIONS):**
- Add confirmation format: "Added: [Title] · [Day] · [Time]"  (e.g., "Added: Team standup · Tue · 3:00pm")
- Schedule display: one event per line — "• Tue 3pm — Team standup"
- Tone: efficient assistant — crisp, no filler words, no emojis, gets to the point
- Calendar conflict: warn and ask — "You already have [X] at that time. Add anyway? Reply 'yes' to confirm."
- Calendar API/auth error: plain message — "Couldn't connect to Google Calendar. Check your account settings."
- Missing required field: ask for single missing piece — "When should I schedule that?" or "What should I call this meeting?"
- Not connected: return connection URL — "To use calendar features, connect your Google Calendar: [url]"

**Anti-patterns to avoid (from RESEARCH.md):**
- NEVER call `service.events().insert().execute()` directly in async context — always wrap in asyncio.to_thread
- NEVER use `calendar` scope — use `calendar.events` only (already enforced in flow.py)
- NEVER store credentials in session memory — always fetch from Supabase via get_credentials_for_user()
- Catch google.auth.exceptions.RefreshError separately and delete tokens + prompt re-auth

```python
"""Calendar skill for secretary mode.

Handles two intents:
  - calendar_add (SECR-01): parse date/title, check conflicts, create event, confirm
  - calendar_view (SECR-02): list upcoming events as formatted bullet list

Uses Google Calendar API v3 via google-api-python-client.
All API calls are wrapped in asyncio.to_thread — never blocks the event loop.
"""
import asyncio
import logging
from datetime import datetime, timedelta, timezone

import dateparser
from google.auth.exceptions import RefreshError
from googleapiclient.discovery import build

from app.services.google_auth.flow import get_credentials_for_user, get_auth_url
from app.services.google_auth.token_store import delete_calendar_tokens
from app.services.skills.registry import ParsedIntent, Skill, register

logger = logging.getLogger(__name__)

# Response templates (per CONTEXT.md locked decisions)
NOT_CONNECTED_MSG = "To use calendar features, connect your Google Calendar: {url}"
CALENDAR_ERROR_MSG = "Couldn't connect to Google Calendar. Check your account settings."
REVOKED_MSG = "Your Google Calendar access was revoked. Reconnect here: {url}"
MISSING_TITLE_MSG = "What should I call this meeting?"
MISSING_TIME_MSG = "When should I schedule that?"
CONFLICT_MSG = "You already have '{title}' at that time. Add anyway? Reply 'yes' to confirm."
CONFLICT_CONFIRM_KEYWORDS = {"yes", "y", "yeah", "oui", "yep"}
NO_EVENTS_MSG = "Nothing on your calendar for the next 7 days."


def _format_event_time(event: dict) -> str:
    """Format event start time as 'Mon 3:00pm'."""
    start = event.get("start", {})
    dt_str = start.get("dateTime") or start.get("date")
    if not dt_str:
        return "?"
    try:
        dt = datetime.fromisoformat(dt_str.replace("Z", "+00:00"))
        return dt.strftime("%a %-I:%M%p").lower().replace(":00", "")
    except ValueError:
        return dt_str[:10]


def _format_duration(start_dt: datetime, end_dt: datetime) -> str:
    """Format 'Tue · 3:00pm' for confirmation message."""
    return start_dt.strftime("%a · %-I:%M%p").lower()


def _parse_user_date(date_string: str, user_tz: str) -> datetime | None:
    """Parse multilingual date string into aware datetime using dateparser.

    Languages: FR + EN. PREFER_DATES_FROM=future so 'Tuesday' means next Tuesday.
    Returns None if unparseable — caller should ask for clarification.
    """
    return dateparser.parse(
        date_string,
        languages=["fr", "en"],
        settings={
            "TIMEZONE": user_tz,
            "RETURN_AS_TIMEZONE_AWARE": True,
            "PREFER_DATES_FROM": "future",
            "PREFER_DAY_OF_MONTH": "first",  # "next month" → 1st of next month
        },
    )


async def _get_service(user_id: str):
    """Load credentials and build Calendar service. Returns (service, error_message).

    Returns (None, error_msg) if not connected or tokens revoked.
    """
    try:
        creds = await get_credentials_for_user(user_id)
    except RefreshError:
        await delete_calendar_tokens(user_id)
        url = get_auth_url()
        return None, REVOKED_MSG.format(url=url)

    if creds is None:
        url = get_auth_url()
        return None, NOT_CONNECTED_MSG.format(url=url)

    try:
        service = await asyncio.to_thread(build, "calendar", "v3", credentials=creds)
        return service, None
    except Exception as e:
        logger.error(f"Failed to build Calendar service for {user_id}: {e}")
        return None, CALENDAR_ERROR_MSG


async def _check_conflicts(service, start_dt: datetime, end_dt: datetime) -> list[dict]:
    """Return events overlapping [start_dt, end_dt) on the primary calendar."""
    def _query():
        result = (
            service.events()
            .list(
                calendarId="primary",
                timeMin=start_dt.isoformat(),
                timeMax=end_dt.isoformat(),
                singleEvents=True,
                orderBy="startTime",
            )
            .execute()
        )
        return result.get("items", [])

    try:
        return await asyncio.to_thread(_query)
    except Exception as e:
        logger.error(f"Conflict check failed: {e}")
        return []


async def _create_event(service, title: str, start_dt: datetime, end_dt: datetime, user_tz: str) -> dict:
    """Create a calendar event. Runs synchronous insert in thread pool."""
    event_body = {
        "summary": title,
        "start": {"dateTime": start_dt.isoformat(), "timeZone": user_tz},
        "end": {"dateTime": end_dt.isoformat(), "timeZone": user_tz},
    }
    def _insert():
        return service.events().insert(calendarId="primary", body=event_body).execute()

    return await asyncio.to_thread(_insert)


async def _list_events(service, max_results: int = 10) -> list[dict]:
    """List upcoming events from now + 7 days."""
    now = datetime.now(timezone.utc)
    week_out = now + timedelta(days=7)

    def _query():
        result = (
            service.events()
            .list(
                calendarId="primary",
                timeMin=now.isoformat(),
                timeMax=week_out.isoformat(),
                maxResults=max_results,
                singleEvents=True,
                orderBy="startTime",
            )
            .execute()
        )
        return result.get("items", [])

    return await asyncio.to_thread(_query)


class CalendarSkill:
    """Handles calendar_add and calendar_view intents.

    Implements Skill Protocol: handle(user_id, intent, user_tz) -> str
    """

    async def handle(self, user_id: str, intent: ParsedIntent, user_tz: str) -> str:
        if intent.skill == "calendar_add":
            return await self._handle_add(user_id, intent, user_tz)
        elif intent.skill == "calendar_view":
            return await self._handle_view(user_id, user_tz)
        else:
            return CALENDAR_ERROR_MSG

    async def _handle_add(self, user_id: str, intent: ParsedIntent, user_tz: str) -> str:
        """Add a meeting to Google Calendar (SECR-01)."""
        # --- Missing field checks (ask for single missing piece) ---
        if not intent.extracted_title:
            return MISSING_TITLE_MSG
        if not intent.extracted_date:
            return MISSING_TIME_MSG

        # --- Parse date ---
        start_dt = _parse_user_date(intent.extracted_date, user_tz)
        if start_dt is None:
            return MISSING_TIME_MSG

        # Default event duration: 1 hour
        end_dt = start_dt + timedelta(hours=1)

        # --- Load Calendar service ---
        service, error = await _get_service(user_id)
        if error:
            return error

        # --- Conflict detection ---
        try:
            conflicts = await _check_conflicts(service, start_dt, end_dt)
            if conflicts:
                conflicting_title = conflicts[0].get("summary", "another event")
                return CONFLICT_MSG.format(title=conflicting_title)
        except Exception as e:
            logger.error(f"Conflict check error for {user_id}: {e}")
            # Non-fatal — proceed to create without conflict check

        # --- Create event ---
        try:
            await _create_event(service, intent.extracted_title, start_dt, end_dt, user_tz)
        except Exception as e:
            logger.error(f"Event creation failed for {user_id}: {e}")
            return CALENDAR_ERROR_MSG

        # --- Confirmation reply (CONTEXT.md format) ---
        time_part = start_dt.strftime("%-I:%M%p").lower()
        day_part = start_dt.strftime("%a")
        return f"Added: {intent.extracted_title} · {day_part} · {time_part}"

    async def _handle_view(self, user_id: str, user_tz: str) -> str:
        """List upcoming events (SECR-02)."""
        service, error = await _get_service(user_id)
        if error:
            return error

        try:
            events = await _list_events(service)
        except Exception as e:
            logger.error(f"Event listing failed for {user_id}: {e}")
            return CALENDAR_ERROR_MSG

        if not events:
            return NO_EVENTS_MSG

        lines = []
        for event in events:
            title = event.get("summary", "Untitled")
            time_str = _format_event_time(event)
            lines.append(f"• {time_str} — {title}")

        return "\n".join(lines)


# Register the skill at import time — importing this module adds it to the registry
_calendar_skill = CalendarSkill()
register("calendar_add", _calendar_skill)
register("calendar_view", _calendar_skill)
```

Note on conflict confirmation: The CONTEXT.md locked decision says to ask "Add anyway?" before overwriting. For Phase 4 this returns the warning message; the "yes" confirmation from the user will be handled as a follow-up calendar_add intent that re-triggers handle_add. A more robust confirmation state machine is Claude's discretion for future refinement.
  </action>
  <verify>
    <automated>cd /c/Users/raphg/Desktop/IA/ava2/backend && python -c "from app.services.skills.calendar_skill import CalendarSkill; from app.services.skills.registry import get, list_skills; assert 'calendar_add' in list_skills(); assert 'calendar_view' in list_skills(); print('calendar_skill registered OK')"</automated>
    <manual>
      Verify the conflict check, missing-field, and not-connected paths are present in the code.
      Check that all service calls use asyncio.to_thread and not direct synchronous calls.
    </manual>
  </verify>
  <done>
    calendar_skill.py imports cleanly; CalendarSkill registered for both 'calendar_add' and 'calendar_view' intents; all Google API calls wrapped in asyncio.to_thread; handle() returns correctly formatted strings per CONTEXT.md decisions
  </done>
</task>

</tasks>

<verification>
```bash
cd /c/Users/raphg/Desktop/IA/ava2/backend && python -m pytest tests/ -x -q
```
All existing tests pass. Calendar skill registers without errors. Key imports verified:
```bash
cd /c/Users/raphg/Desktop/IA/ava2/backend && python -c "
from app.services.skills.calendar_skill import CalendarSkill
from app.services.skills.registry import list_skills
assert set(['calendar_add', 'calendar_view']).issubset(set(list_skills()))
print('calendar skill OK:', list_skills())
"
```
</verification>

<success_criteria>
- CalendarSkill.handle() routes calendar_add to _handle_add() and calendar_view to _handle_view()
- _handle_add: missing title → MISSING_TITLE_MSG, missing date → MISSING_TIME_MSG, dateparser returns None → MISSING_TIME_MSG
- _handle_add: no tokens → NOT_CONNECTED_MSG with auth URL; conflict detected → CONFLICT_MSG with conflicting event title
- _handle_add: success → "Added: [Title] · [Day] · [Time]" format per CONTEXT.md
- _handle_view: no events → NO_EVENTS_MSG; events → bullet list "• Mon 3pm — Team standup"
- All Calendar API calls in asyncio.to_thread (never blocks event loop)
- Both intents registered in skill registry at import time
- All Phase 3 tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-secretary-skills/04-03-SUMMARY.md`
</output>
