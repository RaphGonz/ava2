---
phase: 04-secretary-skills
plan: "03"
type: execute
wave: 2
depends_on: ["04-01", "04-02"]
files_modified:
  - backend/app/services/skills/calendar_skill.py
  - backend/app/services/session/store.py
autonomous: true
requirements: [SECR-01, SECR-02]

must_haves:
  truths:
    - "User can say 'add team standup Tuesday at 3pm' and the bot adds it to Google Calendar and replies 'Added: Team standup · Tue · 3:00pm'"
    - "User can ask 'what's on my calendar?' and the bot lists upcoming events as bullet points"
    - "When no tokens exist, bot replies with a link to connect Google Calendar instead of failing"
    - "When a calendar conflict exists, bot warns and asks for confirmation before adding"
    - "When the user replies 'yes' (or 'oui') after a conflict warning, the event is actually created"
    - "When a meeting title or time is missing, bot asks for the single missing piece"
    - "When Google Calendar API errors, bot replies with a plain error message — no stack traces"
    - "All Google API calls run in asyncio.to_thread — FastAPI event loop is never blocked"
  artifacts:
    - path: "backend/app/services/skills/calendar_skill.py"
      provides: "CalendarSkill class with handle() implementing SECR-01 and SECR-02; PendingCalendarAdd dataclass; execute_pending_add() helper"
      contains: "class CalendarSkill"
      exports: ["CalendarSkill", "PendingCalendarAdd", "execute_pending_add"]
    - path: "backend/app/services/session/store.py"
      provides: "SessionState.pending_calendar_add field for conflict confirmation state"
      contains: "pending_calendar_add"
  key_links:
    - from: "backend/app/services/skills/calendar_skill.py"
      to: "backend/app/services/google_auth/flow.py"
      via: "get_credentials_for_user() to load and refresh tokens"
      pattern: "get_credentials_for_user"
    - from: "backend/app/services/skills/calendar_skill.py"
      to: "googleapiclient.discovery.build"
      via: "asyncio.to_thread wrapping synchronous build() call"
      pattern: "asyncio\\.to_thread"
    - from: "backend/app/services/skills/calendar_skill.py"
      to: "dateparser.parse"
      via: "parse_user_date() helper with FR+EN, PREFER_DATES_FROM=future"
      pattern: "dateparser\\.parse"
    - from: "backend/app/services/skills/calendar_skill.py"
      to: "backend/app/services/skills/registry.py"
      via: "CalendarSkill registered on module import"
      pattern: "register\\("
    - from: "backend/app/services/session/store.py"
      to: "backend/app/services/skills/calendar_skill.py"
      via: "SessionState.pending_calendar_add stores PendingCalendarAdd; ChatService reads it before intent classification (Plan 05)"
      pattern: "pending_calendar_add"
---

<objective>
Build the calendar skill that handles SECR-01 (add meeting) and SECR-02 (view schedule), wired to Google Calendar API via the OAuth infrastructure from Plan 02. Implement a working conflict confirmation path using session state.

Purpose: Users must be able to manage their Google Calendar via WhatsApp chat. This plan implements the CalendarSkill class satisfying both calendar intents, with conflict detection and a working confirmation loop (pending_calendar_add in session state), missing-field prompting, multilingual date parsing (FR+EN), and graceful error handling.

Output:
- backend/app/services/skills/calendar_skill.py — CalendarSkill implementing the Skill Protocol, registered in the skill registry; exports PendingCalendarAdd dataclass and execute_pending_add() helper
- backend/app/services/session/store.py — SessionState gains pending_calendar_add field
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-secretary-skills/04-CONTEXT.md
@.planning/phases/04-secretary-skills/04-RESEARCH.md
@.planning/phases/04-secretary-skills/04-01-SUMMARY.md
@.planning/phases/04-secretary-skills/04-02-SUMMARY.md
@backend/app/services/skills/registry.py
@backend/app/services/google_auth/flow.py
@backend/app/services/google_auth/token_store.py
@backend/app/services/session/store.py
@backend/app/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add pending_calendar_add field to SessionState</name>
  <files>
    backend/app/services/session/store.py
  </files>
  <action>
Add a `pending_calendar_add` field to the `SessionState` dataclass. This field stores a `PendingCalendarAdd` instance (imported from calendar_skill) when a conflict is detected and the user must confirm before the event is created. ChatService (Plan 05) checks this field BEFORE intent classification, mirroring the existing `pending_switch_to` pattern.

**Do NOT import from calendar_skill directly in store.py** — that would create a circular import (store imports calendar_skill; calendar_skill imports store). Instead, type the field as `Any | None` with a comment, or use `object | None`. The type narrowing happens in chat.py where calendar_skill is already imported.

Make these changes to `backend/app/services/session/store.py`:

1. Add `from typing import Any` to the imports (if not already present).

2. Add `pending_calendar_add: Any | None = None` to `SessionState`, after `pending_switch_to`:

```python
@dataclass
class SessionState:
    mode: ConversationMode = ConversationMode.SECRETARY
    history: dict = field(
        default_factory=lambda: {
            ConversationMode.SECRETARY: [],
            ConversationMode.INTIMATE: [],
        }
    )
    pending_switch_to: ConversationMode | None = None  # clarification gate: mode switch
    pending_calendar_add: Any | None = None  # clarification gate: calendar conflict confirmation
```

3. In `SessionStore.reset_session()`, the existing `self._sessions[user_id] = SessionState()` already resets both fields — no change needed there.

4. No other changes to store.py. The field defaults to None and is mutated directly by calendar_skill and chat.py.
  </action>
  <verify>
    <automated>cd /c/Users/raphg/Desktop/IA/ava2/backend && python -c "
from app.services.session.store import SessionState
s = SessionState()
assert hasattr(s, 'pending_calendar_add'), 'pending_calendar_add field missing'
assert s.pending_calendar_add is None, 'pending_calendar_add should default to None'
print('SessionState.pending_calendar_add OK')
"</automated>
  </verify>
  <done>
    SessionState has pending_calendar_add field defaulting to None; existing tests still pass; no circular imports introduced
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement CalendarSkill with conflict confirmation via session state</name>
  <files>
    backend/app/services/skills/calendar_skill.py
  </files>
  <action>
Create backend/app/services/skills/calendar_skill.py implementing the full CalendarSkill with a working conflict confirmation path.

**Key design constraints from CONTEXT.md (LOCKED DECISIONS):**
- Add confirmation format: "Added: [Title] · [Day] · [Time]"  (e.g., "Added: Team standup · Tue · 3:00pm")
- Schedule display: one event per line — "• Tue 3pm — Team standup"
- Tone: efficient assistant — crisp, no filler words, no emojis, gets to the point
- Calendar conflict: warn and ask — "You already have [X] at that time. Add anyway? Reply 'yes' to confirm." — user confirms before overwriting (LOCKED: must have a working confirmation path)
- Calendar API/auth error: plain message — "Couldn't connect to Google Calendar. Check your account settings."
- Missing required field: ask for single missing piece — "When should I schedule that?" or "What should I call this meeting?"
- Not connected: return connection URL — "To use calendar features, connect your Google Calendar: [url]"

**Confirmation state machine (Option A — session state):**
The locked decision requires user confirmation before overwriting. "yes" from the user is classified as "chat" by the intent classifier, so re-triggering _handle_add does NOT work. Instead:

1. When a conflict is detected, store a `PendingCalendarAdd` dataclass on `session.pending_calendar_add`.
2. Return `CONFLICT_MSG` to the user.
3. On the next message, ChatService (Plan 05) checks `session.pending_calendar_add` BEFORE calling the intent classifier. If set and the user replied "yes"/"oui"/etc., ChatService calls `execute_pending_add(session, user_id)` and returns the result. If the user replied anything else, the pending add is cancelled and the message routes normally.

This mirrors the existing `pending_switch_to` / `pending_calendar_add` state machine pattern in ChatService.

**Anti-patterns to avoid (from RESEARCH.md):**
- NEVER call `service.events().insert().execute()` directly in async context — always wrap in asyncio.to_thread
- NEVER use `calendar` scope — use `calendar.events` only (already enforced in flow.py)
- NEVER store credentials in session memory — always fetch from Supabase via get_credentials_for_user()
- Catch google.auth.exceptions.RefreshError separately and delete tokens + prompt re-auth
- Do NOT define CONFLICT_CONFIRM_KEYWORDS in calendar_skill.py — the confirmation check lives in chat.py (Plan 05) so it runs before intent classification

```python
"""Calendar skill for secretary mode.

Handles two intents:
  - calendar_add (SECR-01): parse date/title, check conflicts, create event, confirm
  - calendar_view (SECR-02): list upcoming events as formatted bullet list

Uses Google Calendar API v3 via google-api-python-client.
All API calls are wrapped in asyncio.to_thread — never blocks the event loop.

Conflict confirmation state machine:
  When a conflict is found, _handle_add stores a PendingCalendarAdd on
  session.pending_calendar_add and returns CONFLICT_MSG. ChatService checks
  this field on the NEXT message, before intent classification, and calls
  execute_pending_add() if the user confirmed. This avoids the problem of
  "yes" being classified as 'chat' intent instead of 'calendar_add'.
"""
import asyncio
import logging
from dataclasses import dataclass
from datetime import datetime, timedelta, timezone

import dateparser
from google.auth.exceptions import RefreshError
from googleapiclient.discovery import build

from app.services.google_auth.flow import get_credentials_for_user, get_auth_url
from app.services.google_auth.token_store import delete_calendar_tokens
from app.services.skills.registry import ParsedIntent, Skill, register

logger = logging.getLogger(__name__)

# Response templates (per CONTEXT.md locked decisions)
NOT_CONNECTED_MSG = "To use calendar features, connect your Google Calendar: {url}"
CALENDAR_ERROR_MSG = "Couldn't connect to Google Calendar. Check your account settings."
REVOKED_MSG = "Your Google Calendar access was revoked. Reconnect here: {url}"
MISSING_TITLE_MSG = "What should I call this meeting?"
MISSING_TIME_MSG = "When should I schedule that?"
CONFLICT_MSG = "You already have '{title}' at that time. Add anyway? Reply 'yes' to confirm."
NO_EVENTS_MSG = "Nothing on your calendar for the next 7 days."


@dataclass
class PendingCalendarAdd:
    """Stores the resolved event details while waiting for conflict confirmation.

    Stored on SessionState.pending_calendar_add. ChatService reads this on the
    next message, before intent classification, and calls execute_pending_add()
    if the user confirms with 'yes' / 'oui' / etc.
    """
    user_id: str
    title: str
    start_dt: datetime
    end_dt: datetime
    user_tz: str


async def execute_pending_add(pending: "PendingCalendarAdd") -> str:
    """Create the calendar event from a confirmed PendingCalendarAdd.

    Called by ChatService after the user confirms a conflict warning.
    Returns the confirmation string or an error message.
    """
    service, error = await _get_service(pending.user_id)
    if error:
        return error

    try:
        await _create_event(service, pending.title, pending.start_dt, pending.end_dt, pending.user_tz)
    except Exception as e:
        logger.error(f"Event creation failed (pending confirm) for {pending.user_id}: {e}")
        return CALENDAR_ERROR_MSG

    time_part = pending.start_dt.strftime("%-I:%M%p").lower()
    day_part = pending.start_dt.strftime("%a")
    return f"Added: {pending.title} · {day_part} · {time_part}"


def _format_event_time(event: dict) -> str:
    """Format event start time as 'Mon 3:00pm'."""
    start = event.get("start", {})
    dt_str = start.get("dateTime") or start.get("date")
    if not dt_str:
        return "?"
    try:
        dt = datetime.fromisoformat(dt_str.replace("Z", "+00:00"))
        return dt.strftime("%a %-I:%M%p").lower().replace(":00", "")
    except ValueError:
        return dt_str[:10]


def _parse_user_date(date_string: str, user_tz: str) -> datetime | None:
    """Parse multilingual date string into aware datetime using dateparser.

    Languages: FR + EN. PREFER_DATES_FROM=future so 'Tuesday' means next Tuesday.
    Returns None if unparseable — caller should ask for clarification.
    """
    return dateparser.parse(
        date_string,
        languages=["fr", "en"],
        settings={
            "TIMEZONE": user_tz,
            "RETURN_AS_TIMEZONE_AWARE": True,
            "PREFER_DATES_FROM": "future",
            "PREFER_DAY_OF_MONTH": "first",  # "next month" → 1st of next month
        },
    )


async def _get_service(user_id: str):
    """Load credentials and build Calendar service. Returns (service, error_message).

    Returns (None, error_msg) if not connected or tokens revoked.
    """
    try:
        creds = await get_credentials_for_user(user_id)
    except RefreshError:
        await delete_calendar_tokens(user_id)
        url = get_auth_url()
        return None, REVOKED_MSG.format(url=url)

    if creds is None:
        url = get_auth_url()
        return None, NOT_CONNECTED_MSG.format(url=url)

    try:
        service = await asyncio.to_thread(build, "calendar", "v3", credentials=creds)
        return service, None
    except Exception as e:
        logger.error(f"Failed to build Calendar service for {user_id}: {e}")
        return None, CALENDAR_ERROR_MSG


async def _check_conflicts(service, start_dt: datetime, end_dt: datetime) -> list[dict]:
    """Return events overlapping [start_dt, end_dt) on the primary calendar."""
    def _query():
        result = (
            service.events()
            .list(
                calendarId="primary",
                timeMin=start_dt.isoformat(),
                timeMax=end_dt.isoformat(),
                singleEvents=True,
                orderBy="startTime",
            )
            .execute()
        )
        return result.get("items", [])

    try:
        return await asyncio.to_thread(_query)
    except Exception as e:
        logger.error(f"Conflict check failed: {e}")
        return []


async def _create_event(service, title: str, start_dt: datetime, end_dt: datetime, user_tz: str) -> dict:
    """Create a calendar event. Runs synchronous insert in thread pool."""
    event_body = {
        "summary": title,
        "start": {"dateTime": start_dt.isoformat(), "timeZone": user_tz},
        "end": {"dateTime": end_dt.isoformat(), "timeZone": user_tz},
    }
    def _insert():
        return service.events().insert(calendarId="primary", body=event_body).execute()

    return await asyncio.to_thread(_insert)


async def _list_events(service, max_results: int = 10) -> list[dict]:
    """List upcoming events from now + 7 days."""
    now = datetime.now(timezone.utc)
    week_out = now + timedelta(days=7)

    def _query():
        result = (
            service.events()
            .list(
                calendarId="primary",
                timeMin=now.isoformat(),
                timeMax=week_out.isoformat(),
                maxResults=max_results,
                singleEvents=True,
                orderBy="startTime",
            )
            .execute()
        )
        return result.get("items", [])

    return await asyncio.to_thread(_query)


class CalendarSkill:
    """Handles calendar_add and calendar_view intents.

    Implements Skill Protocol: handle(user_id, intent, user_tz) -> str

    Conflict confirmation:
        When a conflict is detected, this skill stores a PendingCalendarAdd on
        session.pending_calendar_add and returns CONFLICT_MSG. The confirmation
        handling lives in ChatService (chat.py) where it can intercept the next
        message before intent classification — so 'yes' is caught as a
        confirmation, not misrouted as 'chat' intent.

        CalendarSkill.handle() signature does not receive session directly to
        keep the Skill Protocol clean. Instead, the caller (ChatService) passes
        session into handle() via a keyword argument when in conflict resolution
        mode, OR handle() accepts session as an optional parameter.

        To keep the Skill Protocol interface stable, use an alternative approach:
        CalendarSkill._handle_add() accepts session as a required parameter
        (ChatService already has session in scope and passes it through). The
        public handle() interface gains an optional `session` kwarg.
    """

    async def handle(self, user_id: str, intent: ParsedIntent, user_tz: str, session=None) -> str:
        """Route to the appropriate handler.

        session: SessionState instance passed by ChatService. Required for
                 conflict detection (to set pending_calendar_add). If None,
                 conflict is detected but confirmation path is unavailable —
                 fall back to logging a warning and returning CONFLICT_MSG anyway
                 (the state just won't be stored; Plan 05 ensures session is always passed).
        """
        if intent.skill == "calendar_add":
            return await self._handle_add(user_id, intent, user_tz, session)
        elif intent.skill == "calendar_view":
            return await self._handle_view(user_id, user_tz)
        else:
            return CALENDAR_ERROR_MSG

    async def _handle_add(self, user_id: str, intent: ParsedIntent, user_tz: str, session=None) -> str:
        """Add a meeting to Google Calendar (SECR-01).

        On conflict: stores PendingCalendarAdd on session.pending_calendar_add
        and returns CONFLICT_MSG. ChatService intercepts the next user message
        before intent classification, checks for confirmation, and calls
        execute_pending_add() if confirmed.
        """
        # --- Missing field checks (ask for single missing piece) ---
        if not intent.extracted_title:
            return MISSING_TITLE_MSG
        if not intent.extracted_date:
            return MISSING_TIME_MSG

        # --- Parse date ---
        start_dt = _parse_user_date(intent.extracted_date, user_tz)
        if start_dt is None:
            return MISSING_TIME_MSG

        # Default event duration: 1 hour
        end_dt = start_dt + timedelta(hours=1)

        # --- Load Calendar service ---
        service, error = await _get_service(user_id)
        if error:
            return error

        # --- Conflict detection ---
        try:
            conflicts = await _check_conflicts(service, start_dt, end_dt)
            if conflicts:
                conflicting_title = conflicts[0].get("summary", "another event")
                # Store pending add in session for confirmation on next message.
                # ChatService (Plan 05) checks pending_calendar_add BEFORE intent
                # classification so 'yes' is caught as confirmation, not misrouted.
                if session is not None:
                    session.pending_calendar_add = PendingCalendarAdd(
                        user_id=user_id,
                        title=intent.extracted_title,
                        start_dt=start_dt,
                        end_dt=end_dt,
                        user_tz=user_tz,
                    )
                else:
                    logger.warning(
                        f"Conflict detected for {user_id} but session not passed to handle() — "
                        "confirmation path unavailable. Ensure Plan 05 passes session to skill.handle()."
                    )
                return CONFLICT_MSG.format(title=conflicting_title)
        except Exception as e:
            logger.error(f"Conflict check error for {user_id}: {e}")
            # Non-fatal — proceed to create without conflict check

        # --- Create event ---
        try:
            await _create_event(service, intent.extracted_title, start_dt, end_dt, user_tz)
        except Exception as e:
            logger.error(f"Event creation failed for {user_id}: {e}")
            return CALENDAR_ERROR_MSG

        # --- Confirmation reply (CONTEXT.md format) ---
        time_part = start_dt.strftime("%-I:%M%p").lower()
        day_part = start_dt.strftime("%a")
        return f"Added: {intent.extracted_title} · {day_part} · {time_part}"

    async def _handle_view(self, user_id: str, user_tz: str) -> str:
        """List upcoming events (SECR-02)."""
        service, error = await _get_service(user_id)
        if error:
            return error

        try:
            events = await _list_events(service)
        except Exception as e:
            logger.error(f"Event listing failed for {user_id}: {e}")
            return CALENDAR_ERROR_MSG

        if not events:
            return NO_EVENTS_MSG

        lines = []
        for event in events:
            title = event.get("summary", "Untitled")
            time_str = _format_event_time(event)
            lines.append(f"• {time_str} — {title}")

        return "\n".join(lines)


# Register the skill at import time — importing this module adds it to the registry
_calendar_skill = CalendarSkill()
register("calendar_add", _calendar_skill)
register("calendar_view", _calendar_skill)
```

**Note to Plan 05 executor:** Plan 05 must update `chat.py` to:
1. Add a `pending_calendar_add` confirmation gate immediately after the `pending_switch_to` gate (same pattern).
2. Pass `session` as a kwarg to `skill.handle()` for `calendar_add` intents so conflicts can be stored: `await skill.handle(user_id, intent, user_tz, session=session)`.
3. Import `execute_pending_add` and `PendingCalendarAdd` from `calendar_skill`.

The gate in `chat.py` looks like:
```python
# --- Calendar conflict confirmation gate ---
from app.services.skills.calendar_skill import execute_pending_add, PendingCalendarAdd
CALENDAR_CONFIRM_KEYWORDS = {"yes", "y", "yeah", "yep", "oui"}

if session.pending_calendar_add is not None:
    stripped = incoming_text.strip().lower()
    pending = session.pending_calendar_add
    session.pending_calendar_add = None  # clear regardless of answer
    if stripped in CALENDAR_CONFIRM_KEYWORDS:
        reply = await execute_pending_add(pending)
        await self._store.append_message(user_id, session.mode, {"role": "user", "content": incoming_text})
        await self._store.append_message(user_id, session.mode, {"role": "assistant", "content": reply})
        return reply
    # else: user declined — fall through to normal routing
```
  </action>
  <verify>
    <automated>cd /c/Users/raphg/Desktop/IA/ava2/backend && python -c "
from app.services.skills.calendar_skill import CalendarSkill, PendingCalendarAdd, execute_pending_add
from app.services.skills.registry import list_skills
assert 'calendar_add' in list_skills(), 'calendar_add not registered'
assert 'calendar_view' in list_skills(), 'calendar_view not registered'
# Verify PendingCalendarAdd is a dataclass with expected fields
from dataclasses import fields
field_names = {f.name for f in fields(PendingCalendarAdd)}
assert 'user_id' in field_names
assert 'title' in field_names
assert 'start_dt' in field_names
assert 'end_dt' in field_names
assert 'user_tz' in field_names
print('calendar_skill registered OK, PendingCalendarAdd fields:', field_names)
"</automated>
    <manual>
      Verify in the code:
      1. CONFLICT_CONFIRM_KEYWORDS is NOT defined (removed — lives in chat.py per Plan 05)
      2. _handle_add stores PendingCalendarAdd on session.pending_calendar_add when a conflict is detected
      3. All service calls use asyncio.to_thread
      4. execute_pending_add() is exported and calls _create_event via _get_service
    </manual>
  </verify>
  <done>
    calendar_skill.py imports cleanly; CalendarSkill registered for both 'calendar_add' and 'calendar_view'; PendingCalendarAdd dataclass exported; execute_pending_add() exported; CONFLICT_CONFIRM_KEYWORDS not present; session.pending_calendar_add set when conflict detected; all Google API calls in asyncio.to_thread
  </done>
</task>

</tasks>

<verification>
```bash
cd /c/Users/raphg/Desktop/IA/ava2/backend && python -m pytest tests/ -x -q
```
All existing tests pass. Calendar skill and session state changes verified:
```bash
cd /c/Users/raphg/Desktop/IA/ava2/backend && python -c "
from app.services.session.store import SessionState
from app.services.skills.calendar_skill import CalendarSkill, PendingCalendarAdd, execute_pending_add
from app.services.skills.registry import list_skills
# Session state has new field
s = SessionState()
assert s.pending_calendar_add is None
# Skills registered
assert set(['calendar_add', 'calendar_view']).issubset(set(list_skills()))
# PendingCalendarAdd is a proper dataclass
from dataclasses import fields
assert {f.name for f in fields(PendingCalendarAdd)} == {'user_id', 'title', 'start_dt', 'end_dt', 'user_tz'}
print('All OK:', list_skills())
"
```
</verification>

<success_criteria>
- SessionState.pending_calendar_add field exists, defaults to None
- CalendarSkill.handle() routes calendar_add to _handle_add() and calendar_view to _handle_view()
- _handle_add: missing title → MISSING_TITLE_MSG, missing date → MISSING_TIME_MSG, dateparser returns None → MISSING_TIME_MSG
- _handle_add: no tokens → NOT_CONNECTED_MSG with auth URL
- _handle_add: conflict detected → stores PendingCalendarAdd on session.pending_calendar_add → returns CONFLICT_MSG with conflicting event title
- _handle_add: no conflict → creates event → returns "Added: [Title] · [Day] · [Time]" format per CONTEXT.md
- execute_pending_add(): takes PendingCalendarAdd, creates event, returns confirmation string or CALENDAR_ERROR_MSG
- CONFLICT_CONFIRM_KEYWORDS is NOT defined in calendar_skill.py (belongs in chat.py per Plan 05)
- _handle_view: no events → NO_EVENTS_MSG; events → bullet list "• Mon 3pm — Team standup"
- All Calendar API calls in asyncio.to_thread (never blocks event loop)
- Both intents registered in skill registry at import time
- All Phase 3 tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-secretary-skills/04-03-SUMMARY.md`
</output>
