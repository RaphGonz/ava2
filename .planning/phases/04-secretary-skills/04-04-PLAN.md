---
phase: 04-secretary-skills
plan: "04"
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - backend/app/services/skills/research_skill.py
autonomous: true
requirements: [SECR-03]

must_haves:
  truths:
    - "User can ask a factual question and receive a 3-5 sentence answer with one source link at the end"
    - "Broad or ambiguous questions receive a clarifying question back, not a rushed answer"
    - "When Tavily has no solid result, bot answers best-effort with 'I'm not fully certain, but...'"
    - "When Tavily API fails, bot gives a practical error message — no exception details exposed"
    - "Research skill is registered in the skill registry at import time"
  artifacts:
    - path: "backend/app/services/skills/research_skill.py"
      provides: "ResearchSkill class implementing Skill Protocol, registered for 'research' intent"
      contains: "class ResearchSkill"
      exports: ["ResearchSkill"]
  key_links:
    - from: "backend/app/services/skills/research_skill.py"
      to: "tavily.TavilyClient"
      via: "asyncio.to_thread wrapping synchronous TavilyClient.search()"
      pattern: "asyncio\\.to_thread"
    - from: "backend/app/services/skills/research_skill.py"
      to: "backend/app/services/skills/registry.py"
      via: "register('research', _research_skill) at module import time"
      pattern: "register\\("
---

<objective>
Build the research skill that answers factual questions via Tavily API (SECR-03).

Purpose: Users must be able to ask the bot to research a topic and get a concise, sourced answer. This plan implements ResearchSkill using Tavily's include_answer field to skip a separate LLM summarization step, formatted to CONTEXT.md specs.

Output: backend/app/services/skills/research_skill.py — ResearchSkill implementing the Skill Protocol, registered for the 'research' intent. Independent of Plans 02 and 03 (no calendar dependency).
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-secretary-skills/04-CONTEXT.md
@.planning/phases/04-secretary-skills/04-RESEARCH.md
@.planning/phases/04-secretary-skills/04-01-SUMMARY.md
@backend/app/services/skills/registry.py
@backend/app/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement ResearchSkill with Tavily API integration</name>
  <files>
    backend/app/services/skills/research_skill.py
  </files>
  <action>
Create backend/app/services/skills/research_skill.py implementing ResearchSkill.

**Key design constraints from CONTEXT.md (LOCKED DECISIONS):**
- Length: one sharp paragraph, 3-5 sentences max — the core answer concisely
- Sources: one source link appended at the end: "Source: [url]"
- Broad/ambiguous questions: ask one clarifying question before answering ("That's a big topic — are you thinking about X, Y, or Z?")
- Follow-up offers: NONE — give the answer and stop; user asks if they want more
- No solid results: best-effort with caveat — "I'm not fully certain, but..." — never hard-refuse
- Tone: efficient assistant — crisp, no filler words, no emojis, gets to the point

**Anti-patterns to avoid (from RESEARCH.md):**
- TavilyClient.search() is synchronous — ALWAYS wrap in asyncio.to_thread
- Handle 429 and auth errors gracefully — return "couldn't research that right now" message
- Do NOT make an extra LLM call to summarize — Tavily include_answer="advanced" gives the answer pre-formatted

```python
"""Research skill for secretary mode.

Handles 'research' intent (SECR-03): searches Tavily and returns a concise
3-5 sentence answer with one source link.

Design:
- Tavily include_answer="advanced" returns an AI-generated answer — no extra LLM call needed
- TavilyClient.search() is synchronous — wrapped in asyncio.to_thread
- Broad/ambiguous queries (detected by low confidence signal) ask one clarifying question
- Graceful degradation: Tavily API failure → plain error message, never exception details
"""
import asyncio
import logging

from tavily import TavilyClient

from app.config import settings
from app.services.skills.registry import ParsedIntent, Skill, register

logger = logging.getLogger(__name__)

# Response templates (per CONTEXT.md locked decisions)
RESEARCH_ERROR_MSG = "Couldn't look that up right now — try again in a moment."
NO_ANSWER_MSG = "I'm not fully certain, but this topic doesn't have a clear consensus answer yet. Try rephrasing or ask for a specific aspect of it."
AMBIGUOUS_QUERY_MSG = "That's a broad topic — are you looking for a general overview, a recent development, or something specific about it?"

# Minimum answer length to use directly (avoid "I don't know" style Tavily non-answers)
MIN_ANSWER_LENGTH = 20


def _is_query_ambiguous(query: str | None) -> bool:
    """Heuristic: single-word or very short queries are likely ambiguous/broad.

    A one-word query like "physics" or "history" needs clarification.
    Full-sentence questions ("What is quantum entanglement?") are specific enough.
    Per CONTEXT.md: ask one clarifying question for broad questions.
    """
    if not query:
        return True
    words = query.strip().split()
    # Fewer than 3 words and no question word → likely ambiguous
    question_starters = {"what", "how", "why", "when", "where", "who", "which",
                         "qu", "comment", "pourquoi", "quand", "où", "qui"}
    first_word = words[0].lower().rstrip("'")
    return len(words) < 3 and first_word not in question_starters


async def _search_tavily(query: str, api_key: str) -> tuple[str, str]:
    """Run Tavily search and return (answer_text, source_url).

    Returns ("", "") on any failure — caller handles gracefully.
    TavilyClient.search() is synchronous — runs in asyncio.to_thread.
    """
    try:
        client = TavilyClient(api_key=api_key)
        response = await asyncio.to_thread(
            client.search,
            query,
            include_answer="advanced",
            max_results=3,
            search_depth="basic",
        )
        answer = response.get("answer") or ""
        results = response.get("results", [])
        source_url = results[0]["url"] if results else ""
        return answer, source_url
    except Exception as e:
        logger.error(f"Tavily search failed for query '{query}': {e}")
        return "", ""


class ResearchSkill:
    """Handles the 'research' intent (SECR-03).

    Implements Skill Protocol: handle(user_id, intent, user_tz) -> str
    """

    async def handle(self, user_id: str, intent: ParsedIntent, user_tz: str) -> str:
        """Answer a research question using Tavily search.

        Steps:
        1. Check if query is too broad — ask clarifying question if so
        2. Check Tavily API key is configured
        3. Run Tavily search in thread pool
        4. Format answer: paragraph + "Source: [url]"
        5. Graceful fallback on any failure
        """
        query = intent.query or intent.raw_text

        # Guard: ambiguous/broad query → ask for clarification (per CONTEXT.md)
        if _is_query_ambiguous(query):
            return AMBIGUOUS_QUERY_MSG

        # Guard: Tavily not configured
        if not settings.tavily_api_key:
            logger.warning("TAVILY_API_KEY not configured — research skill unavailable")
            return RESEARCH_ERROR_MSG

        # Search
        answer, source_url = await _search_tavily(query, settings.tavily_api_key)

        # Handle API failure
        if not answer and not source_url:
            return RESEARCH_ERROR_MSG

        # Handle empty or too-short answer (Tavily occasionally returns minimal text)
        if not answer or len(answer.strip()) < MIN_ANSWER_LENGTH:
            return NO_ANSWER_MSG

        # Format per CONTEXT.md: answer paragraph + one source link, nothing else
        response = answer.strip()
        if source_url:
            response = f"{response}\n\nSource: {source_url}"

        return response


# Register at import time — importing this module adds 'research' to the registry
_research_skill = ResearchSkill()
register("research", _research_skill)
```
  </action>
  <verify>
    <automated>cd /c/Users/raphg/Desktop/IA/ava2/backend && python -c "from app.services.skills.research_skill import ResearchSkill; from app.services.skills.registry import list_skills; assert 'research' in list_skills(); print('research_skill registered OK')"</automated>
    <manual>
      Confirm research_skill.py uses asyncio.to_thread for TavilyClient.search() call.
      Confirm no LLM summarization call is made (Tavily answer used directly).
    </manual>
  </verify>
  <done>
    research_skill.py imports cleanly; 'research' intent registered in skill registry; asyncio.to_thread wraps TavilyClient.search(); ambiguous query detection returns AMBIGUOUS_QUERY_MSG; missing API key returns RESEARCH_ERROR_MSG; successful search returns answer + "Source: [url]" per CONTEXT.md
  </done>
</task>

</tasks>

<verification>
```bash
cd /c/Users/raphg/Desktop/IA/ava2/backend && python -m pytest tests/ -x -q
```
All existing tests pass. Research skill registers cleanly:
```bash
cd /c/Users/raphg/Desktop/IA/ava2/backend && python -c "
from app.services.skills.research_skill import ResearchSkill
from app.services.skills.registry import list_skills
assert 'research' in list_skills()
print('research skill registered:', list_skills())
"
```
</verification>

<success_criteria>
- ResearchSkill.handle() returns AMBIGUOUS_QUERY_MSG for queries under 3 words with no question word
- ResearchSkill.handle() returns RESEARCH_ERROR_MSG when TAVILY_API_KEY is not set
- ResearchSkill.handle() returns RESEARCH_ERROR_MSG when Tavily API call fails
- ResearchSkill.handle() returns answer + "Source: [url]" for successful searches
- TavilyClient.search() wrapped in asyncio.to_thread (never blocks event loop)
- 'research' intent registered in skill registry at module import time
- All Phase 3 tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-secretary-skills/04-04-SUMMARY.md`
</output>
