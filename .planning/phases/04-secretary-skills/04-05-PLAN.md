---
phase: 04-secretary-skills
plan: "05"
type: execute
wave: 3
depends_on: ["04-01", "04-03", "04-04"]
files_modified:
  - backend/app/services/chat.py
  - backend/app/services/skills/__init__.py
  - backend/tests/test_secretary_skills.py
autonomous: true
requirements: [SECR-01, SECR-02, SECR-03, ARCH-01]

must_haves:
  truths:
    - "Secretary mode messages are classified by intent before reaching the LLM fallback"
    - "calendar_add and calendar_view intents are dispatched to CalendarSkill without hitting the LLM"
    - "research intents are dispatched to ResearchSkill without hitting the LLM"
    - "chat intent falls through to the existing LLM call (no regression)"
    - "Intimate mode messages bypass intent classification entirely and go straight to LLM"
    - "When a conflict warning was sent, replying 'yes' creates the event — not routes as chat"
    - "Automated tests confirm secretary dispatch works end-to-end with mock skills"
  artifacts:
    - path: "backend/app/services/chat.py"
      provides: "ChatService with skill dispatch and pending_calendar_add confirmation gate integrated into secretary mode path"
      contains: "classify_intent"
    - path: "backend/app/services/skills/__init__.py"
      provides: "Eager skill registration — imports all skill modules to populate registry"
      contains: "from app.services.skills"
    - path: "backend/tests/test_secretary_skills.py"
      provides: "Pytest tests for intent dispatch and conflict confirmation in secretary mode"
      contains: "async def test_"
  key_links:
    - from: "backend/app/services/chat.py"
      to: "backend/app/services/skills/intent_classifier.py"
      via: "classify_intent() called in secretary mode before LLM fallback"
      pattern: "classify_intent"
    - from: "backend/app/services/chat.py"
      to: "backend/app/services/skills/registry.py"
      via: "registry.get(intent.skill) to dispatch to registered skill handler"
      pattern: "registry\\.get"
    - from: "backend/app/services/chat.py"
      to: "backend/app/services/skills/calendar_skill.py"
      via: "execute_pending_add() called when pending_calendar_add is set and user confirmed"
      pattern: "execute_pending_add"
    - from: "backend/app/services/skills/__init__.py"
      to: "calendar_skill, research_skill modules"
      via: "import triggers register() calls"
      pattern: "from app.services.skills.calendar_skill"
---

<objective>
Wire the skill dispatch into ChatService so secretary mode routes through intent classification before falling back to the LLM, add the pending_calendar_add confirmation gate for conflict resolution, then add tests confirming the dispatch logic.

Purpose: Plans 01-04 built the skills infrastructure. This plan integrates it into the existing chat pipeline. ChatService.handle_message() must:
1. Check pending_calendar_add before intent classification (so 'yes' resolves a conflict, not routes as chat)
2. Classify intent in secretary mode and dispatch to the correct skill
3. Fall through to LLM for 'chat' intent
4. Leave intimate mode entirely untouched

Output: Updated chat.py with skill dispatch and conflict confirmation gate, updated skills/__init__.py for eager registration, and test_secretary_skills.py with automated tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-secretary-skills/04-CONTEXT.md
@.planning/phases/04-secretary-skills/04-RESEARCH.md
@.planning/phases/04-secretary-skills/04-01-SUMMARY.md
@.planning/phases/04-secretary-skills/04-03-SUMMARY.md
@.planning/phases/04-secretary-skills/04-04-SUMMARY.md
@backend/app/services/chat.py
@backend/app/services/skills/registry.py
@backend/app/services/skills/intent_classifier.py
@backend/app/services/session/models.py
@backend/app/services/session/store.py
@backend/tests/test_mode_detection.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update ChatService with skill dispatch, conflict confirmation gate, and eager skill registration</name>
  <files>
    backend/app/services/chat.py
    backend/app/services/skills/__init__.py
  </files>
  <action>
**Update backend/app/services/skills/__init__.py:**

Replace the empty package marker with eager skill registration imports. Importing this file (which happens when ChatService imports from skills) must trigger all skill register() calls:

```python
"""Skills package — import all skill modules to register them at startup."""
# These imports trigger register() calls in each skill module.
# To add a new skill: create the module and add an import line here.
from app.services.skills import calendar_skill  # noqa: F401  registers calendar_add, calendar_view
from app.services.skills import research_skill  # noqa: F401  registers research
```

**Update backend/app/services/chat.py:**

Integrate two new gates into handle_message() and update imports/init. Both gates sit in the existing flow at precise points.

**Step 1 — Add imports at the top (after existing imports):**
```python
from openai import AsyncOpenAI
from app.services.skills import registry  # triggers eager skill registration via __init__
from app.services.skills.intent_classifier import classify_intent
from app.services.skills.calendar_skill import execute_pending_add, PendingCalendarAdd
from app.config import settings as _settings
```

**Step 2 — Add module-level constant (after import block):**
```python
# Keywords that confirm a pending calendar conflict — lives here so it runs before
# intent classification, where 'yes' would otherwise be classified as 'chat'.
CALENDAR_CONFIRM_KEYWORDS = {"yes", "y", "yeah", "yep", "oui"}
```

**Step 3 — Update ChatService.__init__ to instantiate an AsyncOpenAI client for the intent classifier:**
```python
def __init__(self, llm: LLMProvider, session_store: SessionStore | None = None):
    self._llm = llm
    self._store = session_store or get_session_store()
    # Intent classifier uses a separate AsyncOpenAI client — lightweight fast model call
    self._openai_client = AsyncOpenAI(api_key=_settings.openai_api_key, max_retries=1)
    self._intent_model = _settings.llm_model  # reuse configured model
```

**Step 4 — Add the pending_calendar_add gate IMMEDIATELY AFTER the pending_switch_to gate.**

The existing pending_switch_to gate ends with:
```python
        else:
            # User ignored clarification — cancel pending switch, route normally
            session.pending_switch_to = None
```

Insert this block right after it (before `# --- Mode switch detection ---`):

```python
        # --- Calendar conflict confirmation gate ---
        # Must run BEFORE intent classification: 'yes' is classified as 'chat' by the
        # LLM classifier, so it must be caught here as a conflict confirmation instead.
        if session.pending_calendar_add is not None:
            stripped = incoming_text.strip().lower()
            pending = session.pending_calendar_add
            session.pending_calendar_add = None  # clear regardless of answer
            if stripped in CALENDAR_CONFIRM_KEYWORDS:
                reply = await execute_pending_add(pending)
                await self._store.append_message(
                    user_id, session.mode, {"role": "user", "content": incoming_text}
                )
                await self._store.append_message(
                    user_id, session.mode, {"role": "assistant", "content": reply}
                )
                return reply
            # else: user declined — fall through to normal intent routing
```

**Step 5 — Replace the "Normal message: call LLM" section with skill dispatch + LLM fallback.**

Replace:
```python
        # --- Normal message: call LLM ---
        current_mode = session.mode
        history = list(session.history[current_mode])  # snapshot before append
```

With:
```python
        # --- Normal message: skill dispatch (secretary) or LLM (intimate) ---
        current_mode = session.mode
        history = list(session.history[current_mode])  # snapshot before append

        # Secretary mode: classify intent and dispatch to skill if applicable.
        # Intimate mode: bypass intent classification entirely — go straight to LLM.
        if current_mode == ConversationMode.SECRETARY:
            try:
                intent = await classify_intent(
                    self._openai_client, incoming_text, self._intent_model
                )
                if intent.skill != "chat":
                    user_tz = avatar.get("timezone", "UTC") if avatar else "UTC"
                    skill = registry.get(intent.skill)
                    if skill is not None:
                        # Pass session so calendar_add can store PendingCalendarAdd on conflict
                        skill_reply = await skill.handle(user_id, intent, user_tz, session=session)
                        await self._store.append_message(
                            user_id, current_mode, {"role": "user", "content": incoming_text}
                        )
                        await self._store.append_message(
                            user_id, current_mode, {"role": "assistant", "content": skill_reply}
                        )
                        return skill_reply
            except Exception as e:
                logger.error(f"Skill dispatch failed for user {user_id}, falling back to LLM: {e}")
                # Fall through to LLM on any skill dispatch error — never break the chat
```

The existing LLM call block continues unchanged after this insertion.

**Critical constraints:**
- `if current_mode == ConversationMode.SECRETARY:` gate is mandatory — intimate mode must NEVER call intent classifier (RESEARCH.md Pitfall 6, CONTEXT.md)
- `session=session` kwarg passed to `skill.handle()` — required for CalendarSkill to store PendingCalendarAdd on conflict
- `CALENDAR_CONFIRM_KEYWORDS` gate runs BEFORE mode switch detection and intent classification — ordering is critical
- Skill dispatch errors fall through to LLM silently
- Avatar timezone read from avatar dict; default "UTC" if not present (defensive coding)
  </action>
  <verify>
    <automated>cd /c/Users/raphg/Desktop/IA/ava2/backend && python -c "
from app.services.chat import ChatService
from app.services.skills.registry import list_skills
# Verify skills registered (triggered by chat.py imports)
assert 'calendar_add' in list_skills(), 'calendar_add not registered'
assert 'calendar_view' in list_skills(), 'calendar_view not registered'
assert 'research' in list_skills(), 'research not registered'
# Verify CALENDAR_CONFIRM_KEYWORDS constant exists in chat module
from app.services import chat as chat_mod
assert hasattr(chat_mod, 'CALENDAR_CONFIRM_KEYWORDS'), 'CALENDAR_CONFIRM_KEYWORDS missing from chat.py'
assert 'yes' in chat_mod.CALENDAR_CONFIRM_KEYWORDS
assert 'oui' in chat_mod.CALENDAR_CONFIRM_KEYWORDS
print('ChatService + skill registry + confirm keywords OK:', list_skills())
"</automated>
    <manual>
      Read chat.py and confirm in order:
      1. pending_calendar_add gate appears BEFORE mode switch detection
      2. ConversationMode.SECRETARY gate exists before classify_intent call
      3. skill.handle() is called with session=session kwarg
      4. Intimate mode path is unchanged (no classify_intent call possible)
      5. Skill dispatch error falls through to LLM (try/except with logger.error)
    </manual>
  </verify>
  <done>
    skills/__init__.py imports calendar_skill and research_skill modules; chat.py has CALENDAR_CONFIRM_KEYWORDS constant; pending_calendar_add gate added before mode switch detection; classify_intent + registry.get dispatch in secretary mode; session kwarg passed to skill.handle(); all 3 skills registered when ChatService is imported
  </done>
</task>

<task type="auto">
  <name>Task 2: Write automated tests for secretary skill dispatch and conflict confirmation</name>
  <files>
    backend/tests/test_secretary_skills.py
  </files>
  <action>
Create backend/tests/test_secretary_skills.py with pytest-asyncio tests confirming skill dispatch in ChatService secretary mode, including the conflict confirmation path.

Tests must use mocks to avoid real OpenAI API calls and real Supabase calls. Follow the existing test patterns in backend/tests/test_mode_detection.py.

```python
"""Tests for secretary skill dispatch in ChatService.

Tests confirm:
1. Secretary mode: intent classifier is called; skill handler is dispatched for non-chat intents
2. Intimate mode: intent classifier is NOT called; LLM is called directly
3. Skill dispatch errors fall back to LLM gracefully
4. 'chat' intent falls through to LLM even in secretary mode
5. Calendar conflict confirmation: 'yes' after a conflict warning creates the event
6. Calendar conflict rejection: any other reply cancels and routes normally

Uses unittest.mock.AsyncMock to avoid real API calls.
"""
import pytest
from unittest.mock import AsyncMock, MagicMock, patch
from app.services.chat import ChatService
from app.services.session.models import ConversationMode
from app.services.skills.registry import ParsedIntent
from app.services.skills.calendar_skill import PendingCalendarAdd
from datetime import datetime, timezone


# ---------------------------------------------------------------------------
# Fixtures
# ---------------------------------------------------------------------------

def make_avatar(name: str = "Ava", personality: str = "caring", tz: str = "UTC") -> dict:
    return {"id": "avatar-uuid", "name": name, "personality": personality, "timezone": tz}


@pytest.fixture
def mock_llm():
    llm = MagicMock()
    llm.complete = AsyncMock(return_value="LLM response")
    return llm


@pytest.fixture
def mock_store():
    store = MagicMock()
    session = MagicMock()
    session.mode = ConversationMode.SECRETARY
    session.pending_switch_to = None
    session.pending_calendar_add = None
    session.history = {
        ConversationMode.SECRETARY: [],
        ConversationMode.INTIMATE: [],
    }
    store.get_or_create = AsyncMock(return_value=session)
    store.append_message = AsyncMock()
    store.switch_mode = AsyncMock()
    return store, session


# ---------------------------------------------------------------------------
# Tests: secretary mode dispatch
# ---------------------------------------------------------------------------

@pytest.mark.asyncio
async def test_secretary_calendar_add_dispatches_to_skill(mock_llm, mock_store):
    """calendar_add intent routes to CalendarSkill, not LLM."""
    store, session = mock_store
    service = ChatService(llm=mock_llm, session_store=store)

    calendar_intent = ParsedIntent(
        skill="calendar_add",
        raw_text="Add team standup Tuesday at 3pm",
        extracted_title="team standup",
        extracted_date="Tuesday at 3pm",
    )

    with patch(
        "app.services.chat.classify_intent", new=AsyncMock(return_value=calendar_intent)
    ):
        mock_skill = MagicMock()
        mock_skill.handle = AsyncMock(return_value="Added: Team standup · Tue · 3:00pm")

        with patch("app.services.chat.registry.get", return_value=mock_skill):
            reply = await service.handle_message(
                user_id="user-123",
                incoming_text="Add team standup Tuesday at 3pm",
                avatar=make_avatar(),
            )

    assert reply == "Added: Team standup · Tue · 3:00pm"
    mock_skill.handle.assert_called_once()
    # session kwarg must be passed so conflicts can be stored
    call_kwargs = mock_skill.handle.call_args.kwargs
    assert "session" in call_kwargs, "skill.handle() must receive session= kwarg"
    mock_llm.complete.assert_not_called()  # LLM must NOT be called


@pytest.mark.asyncio
async def test_secretary_research_dispatches_to_skill(mock_llm, mock_store):
    """research intent routes to ResearchSkill, not LLM."""
    store, session = mock_store
    service = ChatService(llm=mock_llm, session_store=store)

    research_intent = ParsedIntent(
        skill="research",
        raw_text="What is quantum entanglement?",
        query="quantum entanglement",
    )

    with patch(
        "app.services.chat.classify_intent", new=AsyncMock(return_value=research_intent)
    ):
        mock_skill = MagicMock()
        mock_skill.handle = AsyncMock(return_value="Quantum entanglement is a phenomenon...\n\nSource: https://example.com")

        with patch("app.services.chat.registry.get", return_value=mock_skill):
            reply = await service.handle_message(
                user_id="user-123",
                incoming_text="What is quantum entanglement?",
                avatar=make_avatar(),
            )

    assert "Quantum entanglement" in reply
    mock_skill.handle.assert_called_once()
    mock_llm.complete.assert_not_called()


@pytest.mark.asyncio
async def test_secretary_chat_intent_falls_through_to_llm(mock_llm, mock_store):
    """'chat' intent bypasses skills and routes to LLM."""
    store, session = mock_store
    service = ChatService(llm=mock_llm, session_store=store)

    chat_intent = ParsedIntent(skill="chat", raw_text="How are you?")

    with patch(
        "app.services.chat.classify_intent", new=AsyncMock(return_value=chat_intent)
    ):
        reply = await service.handle_message(
            user_id="user-123",
            incoming_text="How are you?",
            avatar=make_avatar(),
        )

    assert reply == "LLM response"
    mock_llm.complete.assert_called_once()


@pytest.mark.asyncio
async def test_intimate_mode_bypasses_intent_classifier(mock_llm, mock_store):
    """Intimate mode must NOT call intent classifier — goes straight to LLM."""
    store, session = mock_store
    session.mode = ConversationMode.INTIMATE  # Set to intimate mode
    service = ChatService(llm=mock_llm, session_store=store)

    with patch(
        "app.services.chat.classify_intent", new=AsyncMock()
    ) as mock_classify:
        reply = await service.handle_message(
            user_id="user-123",
            incoming_text="I feel so connected to you",
            avatar=make_avatar(),
        )

    mock_classify.assert_not_called()  # CRITICAL: classifier must not run in intimate mode
    assert reply == "LLM response"


@pytest.mark.asyncio
async def test_skill_dispatch_error_falls_back_to_llm(mock_llm, mock_store):
    """Skill dispatch failure (e.g., network error) falls back to LLM — never crashes."""
    store, session = mock_store
    service = ChatService(llm=mock_llm, session_store=store)

    failing_intent = ParsedIntent(skill="research", raw_text="What is dark matter?", query="dark matter")

    with patch(
        "app.services.chat.classify_intent", new=AsyncMock(return_value=failing_intent)
    ):
        mock_skill = MagicMock()
        mock_skill.handle = AsyncMock(side_effect=Exception("Tavily API down"))

        with patch("app.services.chat.registry.get", return_value=mock_skill):
            reply = await service.handle_message(
                user_id="user-123",
                incoming_text="What is dark matter?",
                avatar=make_avatar(),
            )

    # Falls back to LLM, not an error message
    assert reply == "LLM response"
    mock_llm.complete.assert_called_once()


# ---------------------------------------------------------------------------
# Tests: calendar conflict confirmation gate
# ---------------------------------------------------------------------------

@pytest.mark.asyncio
async def test_yes_confirms_pending_calendar_add(mock_llm, mock_store):
    """When pending_calendar_add is set and user replies 'yes', event is created."""
    store, session = mock_store
    now = datetime.now(timezone.utc)
    # Simulate a stored conflict pending confirmation
    session.pending_calendar_add = PendingCalendarAdd(
        user_id="user-123",
        title="Team standup",
        start_dt=now,
        end_dt=now,
        user_tz="UTC",
    )
    service = ChatService(llm=mock_llm, session_store=store)

    with patch(
        "app.services.chat.execute_pending_add",
        new=AsyncMock(return_value="Added: Team standup · Tue · 3:00pm")
    ) as mock_execute:
        with patch("app.services.chat.classify_intent", new=AsyncMock()) as mock_classify:
            reply = await service.handle_message(
                user_id="user-123",
                incoming_text="yes",
                avatar=make_avatar(),
            )

    assert reply == "Added: Team standup · Tue · 3:00pm"
    mock_execute.assert_called_once()
    # Intent classifier must NOT be called — gate resolves before classifier
    mock_classify.assert_not_called()
    mock_llm.complete.assert_not_called()
    # pending_calendar_add must be cleared after handling
    assert session.pending_calendar_add is None


@pytest.mark.asyncio
async def test_oui_confirms_pending_calendar_add(mock_llm, mock_store):
    """French 'oui' also confirms a pending calendar add."""
    store, session = mock_store
    now = datetime.now(timezone.utc)
    session.pending_calendar_add = PendingCalendarAdd(
        user_id="user-123",
        title="Réunion d'équipe",
        start_dt=now,
        end_dt=now,
        user_tz="Europe/Paris",
    )
    service = ChatService(llm=mock_llm, session_store=store)

    with patch(
        "app.services.chat.execute_pending_add",
        new=AsyncMock(return_value="Added: Réunion d'équipe · Tue · 3:00pm")
    ) as mock_execute:
        reply = await service.handle_message(
            user_id="user-123",
            incoming_text="oui",
            avatar=make_avatar(),
        )

    assert "Réunion" in reply
    mock_execute.assert_called_once()


@pytest.mark.asyncio
async def test_non_yes_cancels_pending_calendar_add(mock_llm, mock_store):
    """Any non-yes reply clears the pending add and routes the message normally."""
    store, session = mock_store
    now = datetime.now(timezone.utc)
    session.pending_calendar_add = PendingCalendarAdd(
        user_id="user-123",
        title="Team standup",
        start_dt=now,
        end_dt=now,
        user_tz="UTC",
    )
    service = ChatService(llm=mock_llm, session_store=store)

    chat_intent = ParsedIntent(skill="chat", raw_text="no thanks")
    with patch(
        "app.services.chat.execute_pending_add", new=AsyncMock()
    ) as mock_execute:
        with patch(
            "app.services.chat.classify_intent", new=AsyncMock(return_value=chat_intent)
        ):
            reply = await service.handle_message(
                user_id="user-123",
                incoming_text="no thanks",
                avatar=make_avatar(),
            )

    # execute_pending_add must NOT be called
    mock_execute.assert_not_called()
    # Message routes normally to LLM (chat intent)
    assert reply == "LLM response"
    mock_llm.complete.assert_called_once()
    # pending_calendar_add must be cleared
    assert session.pending_calendar_add is None
```
  </action>
  <verify>
    <automated>cd /c/Users/raphg/Desktop/IA/ava2/backend && python -m pytest tests/test_secretary_skills.py -v</automated>
    <manual>
      Confirm all 8 tests pass:
      - test_secretary_calendar_add_dispatches_to_skill (+ asserts session kwarg passed)
      - test_secretary_research_dispatches_to_skill
      - test_secretary_chat_intent_falls_through_to_llm
      - test_intimate_mode_bypasses_intent_classifier
      - test_skill_dispatch_error_falls_back_to_llm
      - test_yes_confirms_pending_calendar_add
      - test_oui_confirms_pending_calendar_add
      - test_non_yes_cancels_pending_calendar_add
    </manual>
  </verify>
  <done>
    All 8 new tests pass; all Phase 3 tests still pass; intimate mode guard confirmed by test; skill error fallback to LLM confirmed by test; conflict confirmation gate confirmed by 3 dedicated tests
  </done>
</task>

</tasks>

<verification>
Run full test suite to confirm no regressions:
```bash
cd /c/Users/raphg/Desktop/IA/ava2/backend && python -m pytest tests/ -v
```
Expected: all Phase 3 tests pass, all 8 new secretary skill dispatch tests pass.

Confirm skill registry and confirm keywords are populated when ChatService is imported:
```bash
cd /c/Users/raphg/Desktop/IA/ava2/backend && python -c "
from app.services.chat import ChatService, CALENDAR_CONFIRM_KEYWORDS
from app.services.skills.registry import list_skills
skills = list_skills()
assert 'calendar_add' in skills
assert 'calendar_view' in skills
assert 'research' in skills
assert 'yes' in CALENDAR_CONFIRM_KEYWORDS
assert 'oui' in CALENDAR_CONFIRM_KEYWORDS
print('All skills registered:', skills)
print('Confirm keywords:', CALENDAR_CONFIRM_KEYWORDS)
"
```
</verification>

<success_criteria>
- chat.py has CALENDAR_CONFIRM_KEYWORDS constant with {"yes", "y", "yeah", "yep", "oui"}
- pending_calendar_add gate in chat.py runs BEFORE mode switch detection and intent classification
- pending_calendar_add cleared after handling (whether confirmed or declined)
- skill.handle() called with session=session kwarg for all skills (required for CalendarSkill to store pending state on conflict)
- chat.py integrates classify_intent + registry.get dispatch gated behind ConversationMode.SECRETARY check
- Intimate mode path is entirely unchanged — no classify_intent call possible in intimate mode
- skills/__init__.py imports calendar_skill and research_skill modules (eager registration)
- test_secretary_skills.py has 8 tests all passing: calendar dispatch, research dispatch, chat fallthrough, intimate bypass, error fallback, yes-confirm, oui-confirm, non-yes-cancel
- Full test suite passes: pytest tests/ with 0 failures
- New modular architecture: adding a new skill requires only (a) creating skill module with register() and (b) adding import to skills/__init__.py — no routing logic changes
</success_criteria>

<output>
After completion, create `.planning/phases/04-secretary-skills/04-05-SUMMARY.md`
</output>
