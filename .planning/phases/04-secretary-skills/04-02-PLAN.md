---
phase: 04-secretary-skills
plan: "02"
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/migrations/002_google_calendar_tokens.sql
  - backend/app/services/google_auth/__init__.py
  - backend/app/services/google_auth/token_store.py
  - backend/app/services/google_auth/flow.py
  - backend/app/routers/google_oauth.py
  - backend/app/main.py
autonomous: true
requirements: [SECR-01, SECR-02]

must_haves:
  truths:
    - "google_calendar_tokens table exists in Supabase with RLS — users can only read/write their own row"
    - "User can initiate Google Calendar OAuth by calling GET /auth/google/connect and receiving a redirect URL"
    - "After browser consent, Google redirects to GET /auth/google/callback which stores tokens in Supabase"
    - "get_calendar_tokens() returns stored tokens for a user_id, or None if not connected"
    - "save_calendar_tokens() upserts access_token, refresh_token, token_expiry, scopes for a user"
  artifacts:
    - path: "backend/migrations/002_google_calendar_tokens.sql"
      provides: "CREATE TABLE google_calendar_tokens with RLS policy"
      contains: "CREATE TABLE google_calendar_tokens"
    - path: "backend/app/services/google_auth/token_store.py"
      provides: "get_calendar_tokens() and save_calendar_tokens() async functions"
      contains: "async def get_calendar_tokens"
    - path: "backend/app/services/google_auth/flow.py"
      provides: "get_auth_url() and exchange_code_for_tokens() functions"
      contains: "def get_auth_url"
    - path: "backend/app/routers/google_oauth.py"
      provides: "GET /auth/google/connect and GET /auth/google/callback routes"
      contains: "/auth/google/connect"
  key_links:
    - from: "backend/app/routers/google_oauth.py"
      to: "backend/app/services/google_auth/flow.py"
      via: "get_auth_url() and exchange_code_for_tokens()"
      pattern: "get_auth_url|exchange_code_for_tokens"
    - from: "backend/app/services/google_auth/flow.py"
      to: "google_auth_oauthlib.flow.Flow"
      via: "Flow.from_client_config() with redirect_uri"
      pattern: "Flow\\.from_client_config"
    - from: "backend/app/services/google_auth/token_store.py"
      to: "supabase_admin"
      via: "supabase_admin.table('google_calendar_tokens').upsert()"
      pattern: "google_calendar_tokens"
---

<objective>
Create the Google OAuth infrastructure: DB migration, per-user token store in Supabase, and FastAPI routes that let users connect their Google Calendar via browser consent flow.

Purpose: SECR-01 and SECR-02 (calendar operations) require each user to independently authorize Google Calendar access. This plan builds the OAuth handshake and token persistence layer that calendar_skill.py will use in Plan 03.

Output: SQL migration for google_calendar_tokens table, google_auth package (token_store + flow), google_oauth FastAPI router with /auth/google/connect and /auth/google/callback endpoints.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-secretary-skills/04-CONTEXT.md
@.planning/phases/04-secretary-skills/04-RESEARCH.md
@backend/app/config.py
@backend/app/database.py
@backend/app/main.py
@backend/migrations/001_initial_schema.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: DB migration for google_calendar_tokens and google_auth token store service</name>
  <files>
    backend/migrations/002_google_calendar_tokens.sql
    backend/app/services/google_auth/__init__.py
    backend/app/services/google_auth/token_store.py
  </files>
  <action>
**Create backend/migrations/002_google_calendar_tokens.sql:**

```sql
-- Migration 002: Google Calendar OAuth token storage
-- Per-user token table. Stores access_token, refresh_token, expiry, and scopes.
-- RLS: each user can only read/write their own row.

CREATE TABLE IF NOT EXISTS google_calendar_tokens (
    user_id       UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    access_token  TEXT NOT NULL,
    refresh_token TEXT NOT NULL,
    token_expiry  TIMESTAMPTZ,
    scopes        TEXT[],
    updated_at    TIMESTAMPTZ DEFAULT NOW()
);

ALTER TABLE google_calendar_tokens ENABLE ROW LEVEL SECURITY;

CREATE POLICY "user owns google token" ON google_calendar_tokens
    FOR ALL USING (auth.uid() = user_id);
```

**Create backend/app/services/google_auth/__init__.py** as empty package marker.

**Create backend/app/services/google_auth/token_store.py:**

Handles per-user OAuth token CRUD in Supabase. Uses supabase_admin (service role) for server-to-server writes — consistent with Phase 2 pattern where supabase_admin is reserved for server-side operations.

```python
"""Per-user Google Calendar OAuth token storage in Supabase.

Tokens are stored server-side in the google_calendar_tokens table.
Uses supabase_admin (service role) because the webhook/skill pipeline
runs without a user JWT in scope.

IMPORTANT: Never store tokens in session memory — they must survive restarts.
"""
import logging
from datetime import datetime, timezone
from typing import Any
from app.database import supabase_admin

logger = logging.getLogger(__name__)

TABLE = "google_calendar_tokens"


async def get_calendar_tokens(user_id: str) -> dict[str, Any] | None:
    """Return stored token dict for user_id, or None if not connected."""
    try:
        result = (
            supabase_admin.table(TABLE)
            .select("access_token, refresh_token, token_expiry, scopes")
            .eq("user_id", user_id)
            .maybe_single()
            .execute()
        )
        return result.data if result.data else None
    except Exception as e:
        logger.error(f"Failed to fetch calendar tokens for {user_id}: {e}")
        return None


async def save_calendar_tokens(
    user_id: str,
    access_token: str,
    refresh_token: str,
    token_expiry: datetime | None,
    scopes: list[str],
) -> None:
    """Upsert OAuth tokens for user_id. Called after OAuth callback and after token refresh."""
    try:
        row = {
            "user_id": user_id,
            "access_token": access_token,
            "refresh_token": refresh_token,
            "token_expiry": token_expiry.isoformat() if token_expiry else None,
            "scopes": scopes,
            "updated_at": datetime.now(timezone.utc).isoformat(),
        }
        supabase_admin.table(TABLE).upsert(row).execute()
    except Exception as e:
        logger.error(f"Failed to save calendar tokens for {user_id}: {e}")
        raise


async def delete_calendar_tokens(user_id: str) -> None:
    """Remove stored tokens (e.g., when token is revoked by user)."""
    try:
        supabase_admin.table(TABLE).delete().eq("user_id", user_id).execute()
    except Exception as e:
        logger.error(f"Failed to delete calendar tokens for {user_id}: {e}")
```
  </action>
  <verify>
    <automated>cd /c/Users/raphg/Desktop/IA/ava2/backend && python -c "from app.services.google_auth.token_store import get_calendar_tokens, save_calendar_tokens, delete_calendar_tokens; print('token_store OK')"</automated>
    <manual>Check that 002_google_calendar_tokens.sql file exists and contains CREATE TABLE google_calendar_tokens with RLS policy</manual>
  </verify>
  <done>002_google_calendar_tokens.sql created with RLS; token_store.py imports cleanly with get_calendar_tokens, save_calendar_tokens, delete_calendar_tokens</done>
</task>

<task type="auto">
  <name>Task 2: Google OAuth flow service and /auth/google router</name>
  <files>
    backend/app/services/google_auth/flow.py
    backend/app/routers/google_oauth.py
    backend/app/main.py
  </files>
  <action>
**Create backend/app/services/google_auth/flow.py:**

Wraps google-auth-oauthlib Flow for web server OAuth2. Uses calendar.events scope (not calendar — least privilege as specified in RESEARCH.md anti-patterns).

```python
"""Google OAuth2 flow for Calendar access.

Uses Flow.from_client_config() — web server pattern, not InstalledAppFlow.
Scope: calendar.events only (least privilege — avoids full calendar management access).
"""
import asyncio
from datetime import datetime, timezone
from google_auth_oauthlib.flow import Flow
from google.oauth2.credentials import Credentials
from google.auth.transport.requests import Request
from app.config import settings
from app.services.google_auth.token_store import save_calendar_tokens

SCOPES = ["https://www.googleapis.com/auth/calendar.events"]

_CLIENT_CONFIG = {
    "web": {
        "client_id": settings.google_client_id,
        "client_secret": settings.google_client_secret,
        "auth_uri": "https://accounts.google.com/o/oauth2/auth",
        "token_uri": "https://oauth2.googleapis.com/token",
    }
}


def get_auth_url() -> str:
    """Return the Google OAuth consent URL. User must visit this in a browser."""
    flow = Flow.from_client_config(
        _CLIENT_CONFIG,
        scopes=SCOPES,
        redirect_uri=settings.google_oauth_redirect_uri,
    )
    auth_url, _ = flow.authorization_url(
        access_type="offline",     # required for refresh_token
        prompt="consent",          # always show consent to get refresh_token
        include_granted_scopes="true",
    )
    return auth_url


async def exchange_code_for_tokens(user_id: str, code: str) -> None:
    """Exchange authorization code for tokens and persist them for user_id.

    Runs Flow.fetch_token() in a thread pool — it makes synchronous HTTP calls.
    Raises on failure (caller should catch and show error to user).
    """
    flow = Flow.from_client_config(
        _CLIENT_CONFIG,
        scopes=SCOPES,
        redirect_uri=settings.google_oauth_redirect_uri,
    )
    # fetch_token is synchronous — run in executor to avoid blocking event loop
    await asyncio.to_thread(flow.fetch_token, code=code)

    creds = flow.credentials
    expiry = creds.expiry  # datetime or None
    if expiry and expiry.tzinfo is None:
        expiry = expiry.replace(tzinfo=timezone.utc)

    await save_calendar_tokens(
        user_id=user_id,
        access_token=creds.token,
        refresh_token=creds.refresh_token or "",
        token_expiry=expiry,
        scopes=list(creds.scopes or SCOPES),
    )


async def get_credentials_for_user(user_id: str) -> Credentials | None:
    """Load and auto-refresh credentials for user_id.

    Returns None if user has not connected Google Calendar.
    Raises google.auth.exceptions.RefreshError if token was revoked — caller
    must catch this, delete tokens, and prompt re-authorization.
    """
    from app.services.google_auth.token_store import get_calendar_tokens

    tokens = await get_calendar_tokens(user_id)
    if not tokens:
        return None

    creds = Credentials(
        token=tokens["access_token"],
        refresh_token=tokens["refresh_token"],
        token_uri="https://oauth2.googleapis.com/token",
        client_id=settings.google_client_id,
        client_secret=settings.google_client_secret,
        scopes=tokens.get("scopes") or SCOPES,
    )

    if creds.expired and creds.refresh_token:
        await asyncio.to_thread(creds.refresh, Request())
        expiry = creds.expiry
        if expiry and expiry.tzinfo is None:
            expiry = expiry.replace(tzinfo=timezone.utc)
        await save_calendar_tokens(
            user_id=user_id,
            access_token=creds.token,
            refresh_token=creds.refresh_token or "",
            token_expiry=expiry,
            scopes=list(creds.scopes or SCOPES),
        )

    return creds
```

**Create backend/app/routers/google_oauth.py:**

Two routes: initiate consent flow (returns URL for WhatsApp message) and handle OAuth callback (exchanges code, stores tokens, shows success page).

NOTE: The connect route accepts user_id as a query param. In production this should be a signed state param to prevent CSRF. For Phase 4 this is acceptable — add to security review backlog.

```python
"""Google OAuth routes for Calendar connection.

GET /auth/google/connect?user_id={uuid}  — returns JSON with auth_url for user to click
GET /auth/google/callback?code={code}&state={user_id}  — exchanges code, stores tokens
"""
import logging
from fastapi import APIRouter, HTTPException, Query
from fastapi.responses import HTMLResponse
from app.services.google_auth.flow import get_auth_url, exchange_code_for_tokens

logger = logging.getLogger(__name__)
router = APIRouter(prefix="/auth/google", tags=["google-oauth"])


@router.get("/connect")
async def google_connect(user_id: str = Query(..., description="User UUID from Supabase auth")):
    """Return the Google OAuth consent URL.

    The WhatsApp bot sends this URL to the user when a calendar skill is triggered
    but no tokens exist for them: 'To use calendar features, tap: {url}'
    """
    if not user_id:
        raise HTTPException(status_code=400, detail="user_id is required")
    try:
        auth_url = get_auth_url()
        # Append user_id as state param so callback knows which user to store tokens for
        separator = "&" if "?" in auth_url else "?"
        auth_url_with_state = f"{auth_url}{separator}state={user_id}"
        return {"auth_url": auth_url_with_state}
    except Exception as e:
        logger.error(f"Failed to generate auth URL: {e}")
        raise HTTPException(status_code=500, detail="Could not initiate Google auth")


@router.get("/callback", response_class=HTMLResponse)
async def google_callback(
    code: str = Query(...),
    state: str = Query(..., description="user_id passed through OAuth state"),
):
    """Handle Google OAuth callback. Exchanges code for tokens and stores them."""
    try:
        await exchange_code_for_tokens(user_id=state, code=code)
        return HTMLResponse(
            content="<html><body><h2>Google Calendar connected. You can close this tab.</h2></body></html>",
            status_code=200,
        )
    except Exception as e:
        logger.error(f"OAuth callback failed for user {state}: {e}")
        return HTMLResponse(
            content="<html><body><h2>Could not connect Google Calendar. Please try again.</h2></body></html>",
            status_code=400,
        )
```

**Update backend/app/main.py:**

Add the google_oauth router. Import and include it alongside existing routers. Find the section where existing routers are included (e.g., `app.include_router(auth.router)`) and add:
```python
from app.routers import google_oauth
app.include_router(google_oauth.router)
```
  </action>
  <verify>
    <automated>cd /c/Users/raphg/Desktop/IA/ava2/backend && python -c "from app.routers.google_oauth import router; from app.services.google_auth.flow import get_auth_url, exchange_code_for_tokens, get_credentials_for_user; print('google_auth flow + router OK')"</automated>
    <manual>Confirm main.py includes google_oauth router: grep for google_oauth in main.py</manual>
  </verify>
  <done>flow.py and google_oauth.py import cleanly; main.py includes the google_oauth router; GET /auth/google/connect and /auth/google/callback routes exist in the FastAPI app</done>
</task>

</tasks>

<verification>
```bash
cd /c/Users/raphg/Desktop/IA/ava2/backend && python -m pytest tests/ -x -q
```
All existing Phase 3 tests pass. New OAuth routes registered in app without import errors.

Apply migration manually to Supabase (or note it for user setup):
The SQL in 002_google_calendar_tokens.sql must be run against Supabase before the calendar skill can store tokens. This is documented as a user_setup step.
</verification>

<success_criteria>
- 002_google_calendar_tokens.sql defines google_calendar_tokens table with RLS
- token_store.py provides get_calendar_tokens(), save_calendar_tokens(), delete_calendar_tokens()
- flow.py provides get_auth_url(), exchange_code_for_tokens(), get_credentials_for_user()
- All Google API calls are wrapped in asyncio.to_thread() (no blocking the event loop)
- google_oauth.py router exposes GET /auth/google/connect and GET /auth/google/callback
- main.py includes google_oauth router
- All Phase 3 tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-secretary-skills/04-02-SUMMARY.md`
</output>
