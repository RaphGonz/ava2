---
phase: 04-secretary-skills
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/services/skills/__init__.py
  - backend/app/services/skills/registry.py
  - backend/app/services/skills/intent_classifier.py
  - backend/app/config.py
  - backend/requirements.txt
autonomous: true
requirements: [ARCH-01, SECR-03]

must_haves:
  truths:
    - "Skill registry maps intent strings to Skill protocol instances via register() and get()"
    - "Intent classifier calls OpenAI structured output and returns a valid ParsedIntent with one of four intents"
    - "New skills can be added by calling registry.register() with no routing logic changes"
    - "Config has tavily_api_key field defaulting to empty string (no startup crash if unset)"
    - "All Phase 3 tests still pass after adding new dependencies"
  artifacts:
    - path: "backend/app/services/skills/__init__.py"
      provides: "Package marker"
    - path: "backend/app/services/skills/registry.py"
      provides: "Skill Protocol + _REGISTRY dict + register() and get() functions + ParsedIntent dataclass"
      contains: "class Skill(Protocol)"
    - path: "backend/app/services/skills/intent_classifier.py"
      provides: "classify_intent() async function using OpenAI structured outputs"
      contains: "async def classify_intent"
    - path: "backend/app/config.py"
      provides: "tavily_api_key and google_client_id/secret settings fields"
      contains: "tavily_api_key"
  key_links:
    - from: "backend/app/services/skills/intent_classifier.py"
      to: "openai AsyncOpenAI"
      via: "client.beta.chat.completions.parse with IntentResult response_format"
      pattern: "response_format=IntentResult"
    - from: "backend/app/services/skills/registry.py"
      to: "Skill protocol instances"
      via: "_REGISTRY dict lookup"
      pattern: "_REGISTRY\\.get"
---

<objective>
Create the skill registry foundation and intent classifier that all secretary skills plug into.

Purpose: ARCH-01 requires a modular skill system where new capabilities can be added as plugins without modifying routing logic. This plan establishes the Protocol + registry pattern and the LLM-based intent classifier that routes secretary-mode messages to the correct skill.

Output: backend/app/services/skills/ package with registry.py (Skill Protocol + dict registry), intent_classifier.py (OpenAI structured output classifier), updated config.py (tavily + google creds), updated requirements.txt.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-secretary-skills/04-CONTEXT.md
@.planning/phases/04-secretary-skills/04-RESEARCH.md
@backend/app/services/skills/registry.py
@backend/app/services/skills/intent_classifier.py
@backend/app/config.py
@backend/requirements.txt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create skill registry package with Skill Protocol, ParsedIntent, and registry dict</name>
  <files>
    backend/app/services/skills/__init__.py
    backend/app/services/skills/registry.py
  </files>
  <action>
Create backend/app/services/skills/__init__.py as an empty package marker.

Create backend/app/services/skills/registry.py with the following:

1. ParsedIntent dataclass — the normalized intent object passed to all skill handlers:
   ```python
   from dataclasses import dataclass

   @dataclass
   class ParsedIntent:
       skill: str           # "calendar_add" | "calendar_view" | "research" | "chat"
       raw_text: str        # original user message
       extracted_date: str | None = None   # for calendar intents (e.g. "mardi à 15h")
       extracted_title: str | None = None  # for calendar intents (e.g. "Team standup")
       query: str | None = None            # for research intents
   ```

2. Skill Protocol (runtime_checkable) — the interface every skill must satisfy:
   ```python
   from typing import Protocol, runtime_checkable

   @runtime_checkable
   class Skill(Protocol):
       async def handle(self, user_id: str, intent: ParsedIntent, user_tz: str) -> str:
           ...
   ```
   Note: This matches the project's existing Protocol pattern from backend/app/services/llm/base.py (LLMProvider uses structural typing, not ABC).

3. Module-level registry dict and register/get functions:
   ```python
   _REGISTRY: dict[str, Skill] = {}

   def register(skill_name: str, skill: Skill) -> None:
       """Register a skill handler. Call at module import time in each skill module."""
       _REGISTRY[skill_name] = skill

   def get(skill_name: str) -> Skill | None:
       """Retrieve a registered skill by name. Returns None if not found."""
       return _REGISTRY.get(skill_name)

   def list_skills() -> list[str]:
       """Return list of registered skill names. For debugging and testing."""
       return list(_REGISTRY.keys())
   ```

Do NOT use ABC or inheritance — structural typing via Protocol is the project convention (see LLMProvider in llm/base.py).
  </action>
  <verify>
    <automated>cd /c/Users/raphg/Desktop/IA/ava2/backend && python -c "from app.services.skills.registry import Skill, ParsedIntent, register, get, list_skills; print('registry OK')"</automated>
  </verify>
  <done>registry.py imports cleanly, Skill Protocol and ParsedIntent are importable, register/get/list_skills functions exist</done>
</task>

<task type="auto">
  <name>Task 2: Create intent classifier and update config + requirements</name>
  <files>
    backend/app/services/skills/intent_classifier.py
    backend/app/config.py
    backend/requirements.txt
  </files>
  <action>
**Create backend/app/services/skills/intent_classifier.py:**

LLM-based intent classifier using OpenAI structured outputs with Pydantic response_format. Must handle English and French naturally (bilingual per CONTEXT.md).

```python
"""Intent classifier for secretary mode message routing.

Uses OpenAI structured outputs to classify user messages into one of four intents:
  - calendar_add: user wants to add/schedule/book an event
  - calendar_view: user wants to see their schedule/agenda/upcoming events
  - research: user wants to look up information or get a factual answer
  - chat: general conversation (fallback)

Secretary mode only — ChatService must NOT call this in intimate mode.
"""
import logging
from typing import Literal
from pydantic import BaseModel
from openai import AsyncOpenAI
from app.services.skills.registry import ParsedIntent

logger = logging.getLogger(__name__)

INTENT_CLASSIFIER_PROMPT = """You are an intent classifier for a personal assistant bot.
Classify the user's message into exactly one of these intents:
- "calendar_add": user wants to add, schedule, or book a meeting/event/appointment
- "calendar_view": user wants to see their schedule, upcoming events, calendar, or agenda
- "research": user wants to look up information, get a factual answer, or learn about a topic
- "chat": general conversation, questions about the bot, or anything else

For calendar_add: also extract the event title and the date/time string exactly as the user stated.
For research: also extract the core search query.
Be bilingual — handle English and French naturally.

Examples:
- "Add dentist appointment Tuesday at 2pm" → calendar_add, title="dentist appointment", date="Tuesday at 2pm"
- "Ajoute une réunion d'équipe mardi à 15h" → calendar_add, title="réunion d'équipe", date="mardi à 15h"
- "What's on my calendar?" → calendar_view
- "Qu'est-ce que je fais aujourd'hui?" → calendar_view
- "What is quantum mechanics?" → research, query="quantum mechanics"
- "Qu'est-ce que la mécanique quantique?" → research, query="mécanique quantique"
- "How are you?" → chat"""


class IntentResult(BaseModel):
    intent: Literal["calendar_add", "calendar_view", "research", "chat"]
    extracted_date: str | None = None    # raw date string from user (e.g. "mardi à 15h")
    extracted_title: str | None = None  # event title for calendar_add
    query: str | None = None            # search query for research


async def classify_intent(
    client: AsyncOpenAI, text: str, model: str
) -> ParsedIntent:
    """Classify user message into a ParsedIntent.

    Uses OpenAI structured outputs — guaranteed valid enum, no JSON parsing errors.
    Falls back to 'chat' intent on any error so the message is always handled.
    """
    try:
        response = await client.beta.chat.completions.parse(
            model=model,
            messages=[
                {"role": "system", "content": INTENT_CLASSIFIER_PROMPT},
                {"role": "user", "content": text},
            ],
            response_format=IntentResult,
        )
        result = response.choices[0].message.parsed
        return ParsedIntent(
            skill=result.intent,
            raw_text=text,
            extracted_date=result.extracted_date,
            extracted_title=result.extracted_title,
            query=result.query,
        )
    except Exception as e:
        logger.error(f"Intent classification failed, defaulting to chat: {e}")
        return ParsedIntent(skill="chat", raw_text=text)
```

**Update backend/app/config.py:**

Add three new fields after the existing LLM fields:
```python
# Secretary skills — Google Calendar OAuth
google_client_id: str = ""
google_client_secret: str = ""
google_oauth_redirect_uri: str = "http://localhost:8000/auth/google/callback"

# Secretary skills — Tavily research
tavily_api_key: str = ""
```

All default to empty string — missing keys return graceful error messages, never crash at startup (consistent with openai_api_key pattern already in config).

**Update backend/requirements.txt:**

Add the following lines after the existing dependencies:
```
google-api-python-client>=2.0.0
google-auth-oauthlib>=1.0.0
google-auth-httplib2>=0.2.0
tavily-python==0.7.21
dateparser==1.3.0
```
  </action>
  <verify>
    <automated>cd /c/Users/raphg/Desktop/IA/ava2/backend && pip install -r requirements.txt -q && python -c "from app.services.skills.intent_classifier import classify_intent, INTENT_CLASSIFIER_PROMPT; from app.config import settings; assert hasattr(settings, 'tavily_api_key'); assert hasattr(settings, 'google_client_id'); print('intent classifier + config OK')"</automated>
    <manual>Confirm requirements.txt includes google-api-python-client, tavily-python, dateparser</manual>
  </verify>
  <done>intent_classifier.py imports cleanly, config has tavily_api_key + google_client_id + google_client_secret + google_oauth_redirect_uri fields, all new packages installed</done>
</task>

</tasks>

<verification>
Run existing Phase 3 tests to confirm no regressions:
```
cd /c/Users/raphg/Desktop/IA/ava2/backend && python -m pytest tests/ -x -q
```
All tests pass. New imports resolve cleanly.
</verification>

<success_criteria>
- backend/app/services/skills/ package exists with __init__.py, registry.py, intent_classifier.py
- Skill Protocol (runtime_checkable) with handle(user_id, intent, user_tz) -> str signature
- ParsedIntent dataclass with skill, raw_text, extracted_date, extracted_title, query fields
- register(), get(), list_skills() functions in registry.py
- classify_intent() async function in intent_classifier.py using OpenAI structured outputs
- config.py has tavily_api_key, google_client_id, google_client_secret, google_oauth_redirect_uri
- requirements.txt includes google-api-python-client, google-auth-oauthlib, google-auth-httplib2, tavily-python, dateparser
- All Phase 3 pytest tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-secretary-skills/04-01-SUMMARY.md`
</output>
