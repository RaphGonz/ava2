---
phase: 07-avatar-system-production
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - backend/app/models/avatar.py
  - backend/app/routers/avatars.py
  - backend/app/services/billing/__init__.py
  - backend/app/services/billing/stripe_client.py
  - backend/app/services/billing/subscription.py
  - backend/app/routers/billing.py
  - backend/app/dependencies.py
  - backend/app/config.py
  - backend/app/main.py
  - backend/app/routers/web_chat.py
  - backend/requirements.txt
autonomous: true
requirements: [AVTR-01, AVTR-02, AVTR-03, AVTR-04, BILL-01, BILL-02]

must_haves:
  truths:
    - "POST /avatars with gender and nationality fields succeeds (no 422 validation error)"
    - "GET /avatars/me returns all avatar fields including gender and nationality"
    - "POST /billing/checkout returns a Stripe checkout_url for authenticated user"
    - "POST /billing/webhook verifies Stripe signature and activates subscription on checkout.session.completed"
    - "Chat endpoints return 402 when subscription is inactive"
    - "Stripe price ID is read from env (config-driven — no hardcoded amount)"
  artifacts:
    - path: "backend/app/models/avatar.py"
      provides: "AvatarCreate, AvatarResponse with gender and nationality fields"
      contains: "gender"
    - path: "backend/app/routers/avatars.py"
      provides: "POST /avatars create endpoint with gender and nationality in insert"
      exports: ["router"]
    - path: "backend/app/routers/billing.py"
      provides: "POST /billing/checkout and POST /billing/webhook"
      exports: ["router"]
    - path: "backend/app/services/billing/subscription.py"
      provides: "activate_subscription(), deactivate_subscription(), get_subscription_status()"
      exports: ["activate_subscription", "deactivate_subscription", "get_subscription_status"]
    - path: "backend/app/dependencies.py"
      provides: "require_active_subscription dependency added"
      contains: "require_active_subscription"
    - path: "backend/app/config.py"
      provides: "stripe_secret_key, stripe_webhook_secret, stripe_price_id, sentry_dsn, replicate_api_key fields"
      contains: "stripe_secret_key"
  key_links:
    - from: "backend/app/routers/billing.py"
      to: "backend/app/config.py"
      via: "settings.stripe_price_id (BILL-02 config-driven)"
      pattern: "settings\\.stripe_price_id"
    - from: "backend/app/routers/web_chat.py"
      to: "backend/app/dependencies.py"
      via: "require_active_subscription dependency on POST /chat"
      pattern: "require_active_subscription"
    - from: "backend/app/routers/billing.py"
      to: "backend/app/services/billing/subscription.py"
      via: "activate_subscription() / deactivate_subscription() called from webhook handler"
      pattern: "activate_subscription"
---

<objective>
Extend the avatar data model with gender/nationality fields and add Stripe billing backend with subscription enforcement gate.

Purpose: Completes the AVTR-01 through AVTR-04 avatar field backend, and implements BILL-01/BILL-02 billing infrastructure. Both are needed before the frontend onboarding and subscribe flows can be built in Plan 04/05.

Output: Updated avatar model with gender/nationality in the create path; complete Stripe billing router + subscription helpers; config fields added; `require_active_subscription` dependency wiring chat endpoints.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-avatar-system-production/07-CONTEXT.md
@.planning/phases/07-avatar-system-production/07-RESEARCH.md
@backend/app/models/avatar.py
@backend/app/routers/avatars.py
@backend/app/dependencies.py
@backend/app/config.py
@backend/app/main.py
@backend/app/routers/web_chat.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Avatar model extension — gender/nationality fields on create path only</name>
  <files>
    backend/app/models/avatar.py
    backend/app/routers/avatars.py
  </files>
  <action>
**`backend/app/models/avatar.py`** — Add `gender` and `nationality` fields to AvatarCreate and AvatarResponse. Keep existing fields unchanged. Avatar is locked once created during onboarding — no PATCH/update model needed.

```python
from enum import Enum
from pydantic import BaseModel, Field
from typing import Optional
from datetime import datetime


class PersonalityType(str, Enum):
    playful = "playful"
    dominant = "dominant"
    shy = "shy"
    caring = "caring"
    intellectual = "intellectual"
    adventurous = "adventurous"


class AvatarCreate(BaseModel):
    name: str = Field(..., min_length=1, max_length=100)
    age: int = Field(..., ge=20, description="Avatar age — minimum 20 per compliance policy")
    personality: PersonalityType
    physical_description: Optional[str] = Field(None, max_length=2000)
    gender: Optional[str] = Field(None, max_length=50)         # AVTR-01: new
    nationality: Optional[str] = Field(None, max_length=100)   # AVTR-03: new


class PersonaUpdateRequest(BaseModel):
    personality: PersonalityType


class AvatarResponse(BaseModel):
    id: str
    user_id: str
    name: str
    age: int
    personality: PersonalityType
    physical_description: Optional[str] = None
    gender: Optional[str] = None         # AVTR-01
    nationality: Optional[str] = None    # AVTR-03
    created_at: datetime
```

**`backend/app/routers/avatars.py`** — Two changes only:
1. Update `create_avatar` DB insert to include `gender` and `nationality`
2. Do NOT add a PATCH /avatars/me full-update endpoint — avatar is locked after creation (user decision)

In `create_avatar`, update the insert dict:
```python
result = db.from_("avatars").insert({
    "user_id": str(user.id),
    "name": body.name,
    "age": body.age,
    "personality": body.personality,
    "physical_description": body.physical_description,
    "gender": body.gender,
    "nationality": body.nationality,
}).execute()
```

No other changes to avatars.py in this task. The existing `update_persona` endpoint (PATCH /avatars/me/persona) is unaffected — that only changes personality, not the full avatar.
  </action>
  <verify>
    <automated>cd "C:/Users/raphg/Desktop/IA/ava2/backend" && python -c "from app.models.avatar import AvatarCreate, AvatarResponse; a = AvatarCreate(name='Ava', age=25, personality='caring', gender='woman', nationality='French'); print('AvatarCreate OK:', a.gender, a.nationality); r = AvatarResponse(id='x', user_id='y', name='Ava', age=25, personality='caring', created_at='2026-01-01T00:00:00'); print('AvatarResponse gender field:', r.gender)"</automated>
    <sampling_rate>run after task 1, before task 2</sampling_rate>
  </verify>
  <done>
    AvatarCreate accepts gender and nationality without error. AvatarResponse includes gender and nationality (nullable). create_avatar insert includes gender and nationality. No AvatarUpdate model and no PATCH /avatars/me endpoint — avatar is locked post-creation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Stripe billing backend — router + subscription service + config + subscription gate</name>
  <files>
    backend/app/services/billing/__init__.py
    backend/app/services/billing/stripe_client.py
    backend/app/services/billing/subscription.py
    backend/app/routers/billing.py
    backend/app/dependencies.py
    backend/app/config.py
    backend/app/main.py
    backend/app/routers/web_chat.py
    backend/requirements.txt
  </files>
  <action>
**`backend/app/config.py`** — Add new config fields. Append to the Settings class (keep all existing fields):
```python
# Image generation (Replicate)
replicate_api_token: str = ""  # set REPLICATE_API_TOKEN in .env

# Billing (Stripe)
stripe_secret_key: str = ""        # Stripe Dashboard → Developers → API keys (secret)
stripe_webhook_secret: str = ""    # Stripe Dashboard → Webhooks → signing secret
stripe_price_id: str = ""          # Stripe Dashboard → Products → price ID (config-driven BILL-02)

# Monitoring
sentry_dsn: str = ""               # Sentry project DSN (empty string = disabled)

# Redis (for BullMQ worker)
redis_url: str = "redis://localhost:6379"
```

**`backend/app/services/billing/__init__.py`** — empty

**`backend/app/services/billing/stripe_client.py`** — Stripe session create:
```python
"""
Stripe Checkout session creation and webhook event verification.
stripe_price_id is read from settings — never hardcoded (BILL-02).
"""
import stripe
from app.config import settings

# Module-level API key (global pattern is fine at this scale per RESEARCH.md)
stripe.api_key = settings.stripe_secret_key


def create_checkout_session(user_id: str, email: str | None = None) -> str:
    """
    Create a Stripe Checkout Session for monthly subscription.
    Returns the checkout URL to redirect the user to.

    Config-driven (BILL-02): stripe_price_id comes from settings/env.
    """
    params: dict = {
        "mode": "subscription",
        "line_items": [{"price": settings.stripe_price_id, "quantity": 1}],
        "success_url": f"{settings.frontend_url}/chat?subscribed=1",
        "cancel_url": f"{settings.frontend_url}/subscribe?cancelled=1",
        "client_reference_id": user_id,
        "metadata": {"user_id": user_id},
    }
    if email:
        params["customer_email"] = email
    session = stripe.checkout.Session.create(**params)
    return session.url


def verify_webhook_event(raw_body: bytes, sig_header: str) -> stripe.Event:
    """
    Verify Stripe webhook signature and return the event.
    Raises stripe.error.SignatureVerificationError on mismatch.

    IMPORTANT: raw_body must be the original bytes from await request.body() —
    never pass a parsed JSON dict here (Pitfall 4 from RESEARCH.md).
    """
    return stripe.Webhook.construct_event(
        raw_body, sig_header, settings.stripe_webhook_secret
    )
```

**`backend/app/services/billing/subscription.py`** — DB read/write for subscription status:
```python
"""
Subscription status persistence — reads/writes the subscriptions table in Supabase.
Uses supabase_admin (service role) because Stripe webhooks run without user JWT.
"""
import logging
from datetime import datetime
from app.database import supabase_admin

logger = logging.getLogger(__name__)


async def activate_subscription(
    user_id: str,
    customer_id: str,
    subscription_id: str,
    price_id: str | None = None,
    period_end: datetime | None = None,
) -> None:
    """Upsert subscription row to active status. Called on checkout.session.completed."""
    data: dict = {
        "user_id": user_id,
        "stripe_customer_id": customer_id,
        "stripe_subscription_id": subscription_id,
        "status": "active",
        "updated_at": "now()",
    }
    if price_id:
        data["stripe_price_id"] = price_id
    if period_end:
        data["current_period_end"] = period_end.isoformat()

    try:
        supabase_admin.from_("subscriptions").upsert(
            data, on_conflict="user_id"
        ).execute()
        logger.info(f"Subscription activated for user {user_id}")
    except Exception as e:
        logger.error(f"Failed to activate subscription for user {user_id}: {e}")
        raise


async def deactivate_subscription(subscription_id: str, new_status: str = "inactive") -> None:
    """Set subscription status to inactive/past_due/canceled. Called on payment failure/cancel."""
    try:
        supabase_admin.from_("subscriptions").update({
            "status": new_status,
            "updated_at": "now()",
        }).eq("stripe_subscription_id", subscription_id).execute()
        logger.info(f"Subscription {subscription_id} set to {new_status}")
    except Exception as e:
        logger.error(f"Failed to deactivate subscription {subscription_id}: {e}")
        raise


def get_subscription_status(user_id: str) -> str | None:
    """
    Synchronous check — returns subscription status string or None if no row.
    Returns 'active', 'inactive', 'past_due', 'canceled', or None.
    Used by require_active_subscription FastAPI dependency.
    """
    result = (
        supabase_admin.from_("subscriptions")
        .select("status")
        .eq("user_id", user_id)
        .maybe_single()
        .execute()
    )
    return result.data.get("status") if result.data else None
```

**`backend/app/routers/billing.py`** — Checkout + webhook endpoints:
```python
"""
Billing router — Stripe Checkout and webhook handler.

POST /billing/checkout  — create Stripe Checkout Session (requires auth)
POST /billing/webhook   — Stripe webhook endpoint (no auth — uses signature verification)
"""
import logging
import stripe
from fastapi import APIRouter, Depends, HTTPException, Request
from app.dependencies import get_current_user
from app.services.billing.stripe_client import create_checkout_session, verify_webhook_event
from app.services.billing.subscription import activate_subscription, deactivate_subscription

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/billing", tags=["billing"])


@router.post("/checkout")
async def create_checkout(user=Depends(get_current_user)):
    """
    Create a Stripe Checkout Session and return the redirect URL.
    Frontend redirects user to checkout_url.
    """
    from app.config import settings
    if not settings.stripe_price_id:
        raise HTTPException(status_code=503, detail="Billing not configured")
    try:
        url = create_checkout_session(user_id=str(user.id))
        return {"checkout_url": url}
    except Exception as e:
        logger.error(f"Checkout session creation failed: {e}")
        raise HTTPException(status_code=500, detail="Failed to create checkout session")


@router.post("/webhook")
async def stripe_webhook(request: Request):
    """
    Stripe webhook — verifies signature then handles:
    - checkout.session.completed → activate subscription
    - invoice.payment_failed → deactivate subscription
    - customer.subscription.deleted → cancel subscription

    CRITICAL: await request.body() BEFORE any JSON parsing (Pitfall 4 from RESEARCH.md).
    """
    raw_body = await request.body()
    sig_header = request.headers.get("stripe-signature", "")

    try:
        event = verify_webhook_event(raw_body, sig_header)
    except stripe.error.SignatureVerificationError:
        logger.warning("Stripe webhook signature verification failed")
        raise HTTPException(status_code=400, detail="Invalid webhook signature")
    except Exception as e:
        logger.error(f"Stripe webhook error: {e}")
        raise HTTPException(status_code=400, detail="Webhook processing failed")

    event_type = event["type"]
    data = event["data"]["object"]

    if event_type == "checkout.session.completed":
        user_id = data.get("metadata", {}).get("user_id")
        if user_id:
            await activate_subscription(
                user_id=user_id,
                customer_id=data.get("customer", ""),
                subscription_id=data.get("subscription", ""),
            )

    elif event_type in ("invoice.payment_failed",):
        sub_id = data.get("subscription")
        if sub_id:
            await deactivate_subscription(sub_id, new_status="past_due")

    elif event_type == "customer.subscription.deleted":
        sub_id = data.get("id")
        if sub_id:
            await deactivate_subscription(sub_id, new_status="canceled")

    return {"received": True}
```

**`backend/app/dependencies.py`** — Add `require_active_subscription` at the end of the existing file (preserve all existing functions):
```python
from app.services.billing.subscription import get_subscription_status

async def require_active_subscription(user=Depends(get_current_user)):
    """
    FastAPI dependency — raises 402 Payment Required if user has no active subscription.
    Used on POST /chat (web_chat router) and any other gated endpoints.
    """
    status = get_subscription_status(str(user.id))
    if status != "active":
        raise HTTPException(
            status_code=402,
            detail="Subscription required. Visit /subscribe to activate.",
        )
    return user
```

**`backend/app/routers/web_chat.py`** — Add `require_active_subscription` to the POST /chat endpoint's dependencies. Add the import at the top:
```python
from app.dependencies import get_current_user, require_active_subscription
```
And update the `send_message` endpoint signature to add the dependency:
```python
@router.post("/chat")
async def send_message(
    body: ChatRequest,
    user=Depends(require_active_subscription),  # was: get_current_user
):
```

**`backend/app/main.py`** — Register billing router. Add after the existing `app.include_router(photo.router)` line:
```python
from app.routers import billing
app.include_router(billing.router)
```

**`backend/requirements.txt`** — Add stripe:
```
stripe
```
  </action>
  <verify>
    <automated>cd "C:/Users/raphg/Desktop/IA/ava2/backend" && python -c "from app.routers.billing import router; from app.services.billing.subscription import activate_subscription, deactivate_subscription, get_subscription_status; from app.dependencies import require_active_subscription; from app.config import settings; assert hasattr(settings, 'stripe_secret_key'); assert hasattr(settings, 'stripe_price_id'); assert hasattr(settings, 'sentry_dsn'); assert hasattr(settings, 'replicate_api_token'); print('All billing imports + config fields OK')"</automated>
    <manual>Run `cd backend && python -m pytest tests/ -x -q 2>&1 | tail -5` — should show no new failures (existing 47+ tests still pass).</manual>
    <sampling_rate>run after task 2 completes</sampling_rate>
  </verify>
  <done>
    Config has stripe_secret_key, stripe_webhook_secret, stripe_price_id, sentry_dsn, replicate_api_token, redis_url. Billing router registered in main.py. POST /billing/checkout requires auth and returns checkout_url. POST /billing/webhook verifies Stripe signature. require_active_subscription dependency raises 402 when status != active. POST /chat uses require_active_subscription. Existing tests still pass.
  </done>
</task>

</tasks>

<verification>
- `python -c "from app.models.avatar import AvatarCreate; AvatarCreate(name='x', age=25, personality='caring', gender='woman', nationality='French')"` — no error
- `python -c "from app.routers.billing import router; print([r.path for r in router.routes])"` — shows /billing/checkout and /billing/webhook
- `python -c "from app.dependencies import require_active_subscription"` — no import error
- `grep "stripe_price_id" backend/app/config.py` — found
- `grep "require_active_subscription" backend/app/routers/web_chat.py` — found
- `cd backend && python -m pytest tests/ -x -q 2>&1 | tail -3` — all existing tests pass
- No AvatarUpdate model in avatar.py — avatar is locked post-creation (user decision)
- No PATCH /avatars/me endpoint in avatars.py (full-update) — only existing PATCH /avatars/me/persona remains
</verification>

<success_criteria>
1. AvatarCreate and AvatarResponse include gender and nationality fields
2. POST /avatars insert includes gender and nationality columns
3. No full-update PATCH /avatars/me endpoint — avatar locked after onboarding (user decision: avatar not editable post-signup)
4. POST /billing/checkout creates Stripe Checkout Session with config-driven price ID
5. POST /billing/webhook handles checkout.session.completed + invoice.payment_failed
6. require_active_subscription raises 402 for inactive subscriptions
7. POST /chat gated behind require_active_subscription
8. All new config fields (stripe_*, replicate_api_token, sentry_dsn, redis_url) have empty-string defaults
</success_criteria>

<output>
After completion, create `.planning/phases/07-avatar-system-production/07-02-SUMMARY.md`
</output>
