---
phase: 07-avatar-system-production
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/migrations/004_phase7_avatar_fields.sql
  - backend/app/services/image/__init__.py
  - backend/app/services/image/base.py
  - backend/app/services/image/replicate_provider.py
  - backend/app/services/image/prompt_builder.py
  - backend/app/services/image/watermark.py
autonomous: true
requirements: [AVTR-05, ARCH-03]

must_haves:
  truths:
    - "DB accepts avatar rows with gender and nationality fields (nullable, no schema error)"
    - "subscriptions table exists with user_id, stripe_customer_id, stripe_subscription_id, status columns"
    - "ImageProvider Protocol exists and can be isinstance()-checked at runtime"
    - "ReplicateProvider class satisfies ImageProvider Protocol without inheritance"
    - "prompt_builder.build_avatar_prompt() returns a string combining all avatar fields and scene description"
    - "apply_watermark() returns JPEG bytes with visible text watermark applied"
  artifacts:
    - path: "backend/migrations/004_phase7_avatar_fields.sql"
      provides: "ALTER TABLE avatars ADD COLUMN gender/nationality; CREATE TABLE subscriptions"
      contains: "gender"
    - path: "backend/app/services/image/base.py"
      provides: "ImageProvider Protocol, GeneratedImage dataclass"
      exports: ["ImageProvider", "GeneratedImage"]
    - path: "backend/app/services/image/replicate_provider.py"
      provides: "ReplicateProvider concrete implementation"
      exports: ["ReplicateProvider"]
    - path: "backend/app/services/image/prompt_builder.py"
      provides: "Avatar field → FLUX prompt construction"
      exports: ["build_avatar_prompt"]
    - path: "backend/app/services/image/watermark.py"
      provides: "Pillow watermark + C2PA metadata"
      exports: ["apply_watermark"]
  key_links:
    - from: "backend/app/services/image/replicate_provider.py"
      to: "backend/app/services/image/base.py"
      via: "structural typing (Protocol) — no import of ImageProvider needed"
      pattern: "async def generate"
    - from: "backend/app/services/jobs/processor.py"
      to: "backend/app/services/image/prompt_builder.py"
      via: "build_avatar_prompt() called with avatar dict + scene_description"
      pattern: "build_avatar_prompt"
---

<objective>
Lay the foundational backend infrastructure for Phase 7: DB schema extensions and the swappable ImageProvider layer.

Purpose: Every subsequent plan in this phase depends on these two parallel foundations — the DB tables must exist before billing and avatar model code runs; the ImageProvider must exist before the BullMQ worker can use it.

Output: Migration SQL ready to apply, complete ImageProvider Protocol + Replicate implementation + prompt builder + watermark helper.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-avatar-system-production/07-CONTEXT.md
@.planning/phases/07-avatar-system-production/07-RESEARCH.md
@backend/migrations/003_phase6_preferences.sql
@backend/app/services/llm/base.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: DB migration — avatar new columns + subscriptions table</name>
  <files>backend/migrations/004_phase7_avatar_fields.sql</files>
  <action>
Create `backend/migrations/004_phase7_avatar_fields.sql` with exactly two parts:

**Part 1 — Avatar new fields (nullable to avoid breaking existing rows):**
```sql
BEGIN;

ALTER TABLE public.avatars
  ADD COLUMN IF NOT EXISTS gender      TEXT,
  ADD COLUMN IF NOT EXISTS nationality TEXT;

COMMIT;
```

**Part 2 — Subscriptions table (config-driven for BILL-02):**
```sql
BEGIN;

CREATE TABLE IF NOT EXISTS public.subscriptions (
  id                     UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id                UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  stripe_customer_id     TEXT,
  stripe_subscription_id TEXT UNIQUE,
  stripe_price_id        TEXT,           -- config-driven, no hardcoded amounts
  status                 TEXT NOT NULL DEFAULT 'inactive'
                           CHECK (status IN ('active', 'inactive', 'past_due', 'canceled')),
  current_period_end     TIMESTAMPTZ,
  created_at             TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at             TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Unique user constraint (one subscription row per user)
ALTER TABLE public.subscriptions
  ADD CONSTRAINT subscriptions_user_id_unique UNIQUE (user_id);

-- RLS: user can read their own row; only service role writes (via webhook)
ALTER TABLE public.subscriptions ENABLE ROW LEVEL SECURITY;

CREATE POLICY IF NOT EXISTS "subscriptions_select_own"
  ON public.subscriptions FOR SELECT
  USING (auth.uid() = user_id);

COMMIT;
```

Both statements use `IF NOT EXISTS` — migration is idempotent (safe to re-run, per Phase 6 pattern established in 003_phase6_preferences.sql).

Apply this migration in the Supabase Dashboard SQL editor (Project → SQL Editor → New query → paste → Run). This is a manual step because there is no CLI migration runner in this project.
  </action>
  <verify>
    <automated>grep -l "gender" "C:/Users/raphg/Desktop/IA/ava2/backend/migrations/004_phase7_avatar_fields.sql" && grep -l "subscriptions" "C:/Users/raphg/Desktop/IA/ava2/backend/migrations/004_phase7_avatar_fields.sql"</automated>
    <manual>Apply migration in Supabase Dashboard SQL editor. Verify with: SELECT column_name FROM information_schema.columns WHERE table_name='avatars' AND column_name IN ('gender','nationality'); — should return 2 rows. SELECT table_name FROM information_schema.tables WHERE table_name='subscriptions'; — should return 1 row.</manual>
    <sampling_rate>run once after file is written</sampling_rate>
  </verify>
  <done>Migration file exists containing both ALTER TABLE (gender, nationality) and CREATE TABLE subscriptions with RLS policy. File is idempotent (IF NOT EXISTS guards throughout).</done>
</task>

<task type="auto">
  <name>Task 2: ImageProvider Protocol + Replicate provider + prompt builder + watermark</name>
  <files>
    backend/app/services/image/__init__.py
    backend/app/services/image/base.py
    backend/app/services/image/replicate_provider.py
    backend/app/services/image/prompt_builder.py
    backend/app/services/image/watermark.py
  </files>
  <action>
Create the `backend/app/services/image/` package. Mirror the `backend/app/services/llm/` structure exactly (same structural typing pattern from Phase 3).

**`backend/app/services/image/__init__.py`** — empty (package marker)

**`backend/app/services/image/base.py`** — ImageProvider Protocol (ARCH-03):
```python
"""
ImageProvider Protocol — ARCH-03 compliance.
Mirrors LLMProvider structural pattern from Phase 3 (backend/app/services/llm/base.py).
Any class with async generate() satisfies this Protocol without inheritance.
"""
from typing import Protocol, runtime_checkable
from dataclasses import dataclass


@dataclass
class GeneratedImage:
    url: str     # Temporary Replicate CDN URL — download immediately, expires ~1h
    model: str   # e.g. "black-forest-labs/flux-1.1-pro"
    prompt: str  # Full prompt used (for audit log)


@runtime_checkable
class ImageProvider(Protocol):
    """
    Structural interface for image generation providers (ARCH-03).
    Swapping providers = swap config + new concrete class. No inheritance needed.
    """
    async def generate(
        self,
        prompt: str,
        aspect_ratio: str = "2:3",
    ) -> GeneratedImage:
        ...
```

**`backend/app/services/image/replicate_provider.py`** — Concrete Replicate implementation:
```python
"""
Replicate API image provider using FLUX 1.1 Pro.
Satisfies ImageProvider Protocol via structural typing.
"""
import logging
import replicate
from app.services.image.base import GeneratedImage

logger = logging.getLogger(__name__)

FLUX_MODEL = "black-forest-labs/flux-1.1-pro"


class ReplicateProvider:
    """
    Calls Replicate async_run() with FLUX 1.1 Pro.
    Returns GeneratedImage with temporary CDN URL.

    IMPORTANT: URL expires ~1 hour. Worker must download immediately.
    """

    async def generate(
        self,
        prompt: str,
        aspect_ratio: str = "2:3",
    ) -> GeneratedImage:
        output = await replicate.async_run(
            FLUX_MODEL,
            input={
                "prompt": prompt,
                "aspect_ratio": aspect_ratio,
                "output_format": "jpeg",
                "output_quality": 90,
            },
        )
        # replicate v1.0+: output is a FileOutput or list; str() gives the CDN URL
        url = str(output) if not isinstance(output, list) else str(output[0])
        logger.info(f"Replicate generated image: {url[:80]}...")
        return GeneratedImage(url=url, model=FLUX_MODEL, prompt=prompt)
```

**`backend/app/services/image/prompt_builder.py`** — Avatar fields → FLUX prompt:
```python
"""
Construct a FLUX prompt from avatar fields + scene description.
Called by the BullMQ worker before each Replicate API call.
"""


def build_avatar_prompt(avatar: dict, scene_description: str) -> str:
    """
    Combine avatar fields (name, age, gender, nationality, physical_description)
    with the LLM-provided scene description to form a photorealistic FLUX prompt.

    Args:
        avatar: Full avatar dict from DB (may include None values for new fields).
        scene_description: Scene/pose/setting from the LLM send_photo tool call.

    Returns:
        Complete FLUX prompt string for Replicate.
    """
    name = avatar.get("name") or "woman"
    gender = avatar.get("gender") or "woman"
    age = avatar.get("age") or 25
    nationality = avatar.get("nationality") or ""
    appearance = avatar.get("physical_description") or ""

    parts: list[str] = [f"Photo of {name},"]

    if nationality:
        parts.append(f"a {age}-year-old {nationality} {gender},")
    else:
        parts.append(f"a {age}-year-old {gender},")

    if appearance:
        parts.append(appearance.rstrip(",") + ",")

    parts.append(scene_description.rstrip(",") + ",")

    # Quality anchors for photorealism
    parts.extend([
        "photorealistic, professional photography,",
        "high detail, natural lighting",
    ])

    return " ".join(parts)
```

**`backend/app/services/image/watermark.py`** — Pillow watermark + C2PA-style metadata comment:
```python
"""
Apply a visible watermark to generated images (compliance requirement per CONTEXT.md).
Uses Pillow alpha_composite for transparent text overlay.

C2PA: For beta, we embed C2PA-formatted metadata as an EXIF comment (no trusted CA cert).
This satisfies the audit trail requirement; full CA-signed C2PA is a post-beta hardening task.
"""
import io
import logging
from PIL import Image, ImageDraw, ImageFont

logger = logging.getLogger(__name__)

WATERMARK_TEXT = "© Ava — AI Generated"


def apply_watermark(image_bytes: bytes, text: str = WATERMARK_TEXT) -> bytes:
    """
    Apply semi-transparent text watermark at bottom-right.
    Returns JPEG bytes with watermark applied.

    Args:
        image_bytes: Raw image bytes (JPEG or PNG from Replicate).
        text: Watermark text to overlay.

    Returns:
        JPEG bytes with watermark.
    """
    img = Image.open(io.BytesIO(image_bytes)).convert("RGBA")
    overlay = Image.new("RGBA", img.size, (0, 0, 0, 0))
    draw = ImageDraw.Draw(overlay)

    # Scale font size with image width; minimum 14px for readability
    font_size = max(img.width // 40, 14)
    font: ImageFont.FreeTypeFont | ImageFont.ImageFont
    try:
        # DejaVu is available in standard Ubuntu/Debian Docker images
        font = ImageFont.truetype(
            "/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf", font_size
        )
    except OSError:
        font = ImageFont.load_default()

    bbox = draw.textbbox((0, 0), text, font=font)
    text_w = bbox[2] - bbox[0]
    text_h = bbox[3] - bbox[1]
    margin = font_size

    x = img.width - text_w - margin
    y = img.height - text_h - margin

    # White text, 180/255 opacity (semi-transparent, clearly visible)
    draw.text((x, y), text, font=font, fill=(255, 255, 255, 180))

    watermarked = Image.alpha_composite(img, overlay).convert("RGB")

    output = io.BytesIO()
    watermarked.save(output, format="JPEG", quality=90)
    logger.info(f"Watermark applied to image ({img.width}x{img.height})")
    return output.getvalue()
```

Add `replicate` and `Pillow` (already implicit in Python image work but make it explicit) to `backend/requirements.txt`:
```
replicate
Pillow>=10.0.0
```
  </action>
  <verify>
    <automated>cd "C:/Users/raphg/Desktop/IA/ava2/backend" && python -c "from app.services.image.base import ImageProvider, GeneratedImage; from app.services.image.replicate_provider import ReplicateProvider; from app.services.image.prompt_builder import build_avatar_prompt; from app.services.image.watermark import apply_watermark; print('All imports OK'); p = build_avatar_prompt({'name':'Ava','age':25,'gender':'woman','nationality':'French','physical_description':'dark hair'}, 'sitting on a couch, casual'); print('Prompt OK:', len(p) > 20); assert isinstance(ReplicateProvider(), ImageProvider), 'Protocol check failed'; print('Protocol isinstance OK')"</automated>
    <sampling_rate>run after this task, before next wave</sampling_rate>
  </verify>
  <done>
    All five files exist. Imports succeed without errors. ReplicateProvider() passes isinstance(x, ImageProvider) check. build_avatar_prompt() returns non-empty string. apply_watermark() is importable. `replicate` and `Pillow>=10.0.0` added to requirements.txt.
  </done>
</task>

</tasks>

<verification>
- Migration file exists with both ALTER TABLE and CREATE TABLE subscriptions
- `python -c "from app.services.image.base import ImageProvider; from app.services.image.replicate_provider import ReplicateProvider; assert isinstance(ReplicateProvider(), ImageProvider)"` passes
- `python -c "from app.services.image.prompt_builder import build_avatar_prompt; p = build_avatar_prompt({'name':'Ava','age':25,'gender':'woman','nationality':'French','physical_description':'dark hair'}, 'sitting on couch'); assert 'French' in p and 'couch' in p"` passes
- `python -c "from app.services.image.watermark import apply_watermark"` no import error
- `replicate` in requirements.txt
</verification>

<success_criteria>
1. DB migration SQL file ready to apply (idempotent, IF NOT EXISTS guards)
2. ImageProvider Protocol satisfies ARCH-03 — swappable without touching photo flow
3. ReplicateProvider calls replicate.async_run() with FLUX 1.1 Pro; returns GeneratedImage
4. prompt_builder combines all avatar fields (gender, nationality, age, physical_description) with scene_description
5. watermark.py applies visible Pillow watermark at bottom-right; returns JPEG bytes
</success_criteria>

<output>
After completion, create `.planning/phases/07-avatar-system-production/07-01-SUMMARY.md`
</output>
