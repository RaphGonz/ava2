---
phase: 02-infrastructure-user-management
plan: 04
type: execute
wave: 3
depends_on: ["02-01", "02-02", "02-03"]
files_modified:
  - backend/app/services/whatsapp.py
  - backend/app/services/user_lookup.py
  - backend/app/routers/webhook.py
  - backend/app/models/message.py
  - backend/app/routers/messages.py
autonomous: true
requirements: [PLAT-01]
user_setup:
  - service: meta-whatsapp-cloud-api
    why: "WhatsApp Business API — required to receive and send WhatsApp messages"
    env_vars:
      - name: WHATSAPP_ACCESS_TOKEN
        source: "Meta Developer Console -> Your App -> WhatsApp -> API Setup -> Temporary access token (or permanent token via System User)"
      - name: WHATSAPP_PHONE_NUMBER_ID
        source: "Meta Developer Console -> Your App -> WhatsApp -> API Setup -> Phone number ID"
      - name: WHATSAPP_VERIFY_TOKEN
        source: "Choose any secret string (e.g. 'ava_webhook_secret_2026') — you set this yourself"
    dashboard_config:
      - task: "Create Meta Developer App"
        location: "developers.facebook.com -> My Apps -> Create App -> Business"
      - task: "Add WhatsApp product to app"
        location: "App Dashboard -> Add Products -> WhatsApp"
      - task: "Register webhook URL after starting ngrok"
        location: "App Dashboard -> WhatsApp -> Configuration -> Webhook -> Edit -> set URL to https://{ngrok-url}/webhook"
      - task: "Submit WhatsApp Business Account verification (do this on Day 1 — takes 2-15 business days)"
        location: "Meta Business Manager -> Business Settings -> WhatsApp Accounts -> Add"

must_haves:
  truths:
    - "GET /webhook returns the hub_challenge integer when hub.verify_token matches WHATSAPP_VERIFY_TOKEN"
    - "GET /webhook returns 403 when hub.verify_token does not match"
    - "POST /webhook always returns HTTP 200 even when processing fails internally"
    - "POST /webhook with a text message from a linked phone number sends an echo '[Echo] {text}' back via Meta Graph API"
    - "POST /webhook with a message from an unlinked phone number sends a registration instructions message"
    - "All incoming and outgoing messages are logged to the messages table in Supabase"
    - "Webhook processing errors are logged to stderr but do not cause non-200 responses"
  artifacts:
    - path: "backend/app/services/whatsapp.py"
      provides: "send_whatsapp_message() async function using httpx + Meta Graph API"
      contains: "graph.facebook.com"
    - path: "backend/app/services/user_lookup.py"
      provides: "lookup_user_by_phone() using supabase_admin to query user_preferences"
      contains: "supabase_admin"
    - path: "backend/app/routers/webhook.py"
      provides: "GET /webhook (verify) and POST /webhook (echo handler)"
      exports: ["router"]
    - path: "backend/app/models/message.py"
      provides: "MessageCreate, MessageResponse Pydantic models"
    - path: "backend/app/routers/messages.py"
      provides: "GET /messages endpoint returning user's message history"
  key_links:
    - from: "backend/app/routers/webhook.py"
      to: "backend/app/services/user_lookup.py"
      via: "lookup_user_by_phone(sender_phone) on every incoming message"
      pattern: "lookup_user_by_phone"
    - from: "backend/app/routers/webhook.py"
      to: "backend/app/services/whatsapp.py"
      via: "send_whatsapp_message() for echo and unlinked-user instructions"
      pattern: "send_whatsapp_message"
    - from: "backend/app/services/whatsapp.py"
      to: "https://graph.facebook.com/v19.0/{phone_number_id}/messages"
      via: "httpx.AsyncClient POST with Bearer token"
      pattern: "graph\\.facebook\\.com"
    - from: "backend/app/services/user_lookup.py"
      to: "backend/app/database.py"
      via: "supabase_admin (service role — bypasses RLS for webhook server-to-server context)"
      pattern: "supabase_admin"
---

<objective>
Implement the WhatsApp webhook integration: verify endpoint, echo message handler, outbound message sender, user lookup service, and message logging.

Purpose: PLAT-01 (user can chat via WhatsApp) requires a working end-to-end webhook flow. When a user sends a message to the WhatsApp number, the server looks up their account by phone, echoes the message back, and logs both messages to the database.

Output:
- `GET /webhook` — Meta webhook verification endpoint
- `POST /webhook` — incoming message handler (echo + message logging)
- `send_whatsapp_message()` service — outbound messages via Meta Graph API v19.0
- `lookup_user_by_phone()` service — maps phone number to user account
- `GET /messages` — authenticated endpoint to view message history
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/02-infrastructure-user-management/02-CONTEXT.md
@.planning/phases/02-infrastructure-user-management/02-RESEARCH.md
@.planning/phases/02-infrastructure-user-management/02-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: WhatsApp service functions (send message + user phone lookup)</name>
  <files>
    backend/app/services/whatsapp.py
    backend/app/services/user_lookup.py
    backend/app/models/message.py
  </files>
  <action>
**backend/app/services/whatsapp.py** — implement `send_whatsapp_message` exactly as RESEARCH.md Pattern 4 (Sending messages via Meta Graph API):

```python
import httpx
import logging
from app.config import settings

logger = logging.getLogger(__name__)

GRAPH_API_VERSION = "v19.0"

async def send_whatsapp_message(phone_number_id: str, to: str, text: str) -> None:
    """Send a text message via Meta Cloud API.

    Raises httpx.HTTPStatusError on API errors. Callers must catch.
    Always pin to GRAPH_API_VERSION — Meta deprecates old versions.
    """
    url = f"https://graph.facebook.com/{GRAPH_API_VERSION}/{phone_number_id}/messages"
    headers = {
        "Authorization": f"Bearer {settings.whatsapp_access_token}",
        "Content-Type": "application/json",
    }
    payload = {
        "messaging_product": "whatsapp",
        "recipient_type": "individual",
        "to": to,
        "type": "text",
        "text": {"body": text},
    }
    async with httpx.AsyncClient(timeout=10.0) as client:
        response = await client.post(url, headers=headers, json=payload)
        response.raise_for_status()
        logger.info(f"WhatsApp message sent to {to}: {text[:50]}")
```

**backend/app/services/user_lookup.py** — implement `lookup_user_by_phone` per RESEARCH.md Pattern 6:

```python
from app.database import supabase_admin
import logging

logger = logging.getLogger(__name__)

async def lookup_user_by_phone(phone: str) -> dict | None:
    """Find user by linked WhatsApp phone. Returns user_preferences row or None.

    Uses service role client (supabase_admin) — webhook is server-to-server,
    no user JWT exists in this context. RLS bypass is intentional here.
    """
    try:
        result = (
            supabase_admin
            .from_("user_preferences")
            .select("user_id")
            .eq("whatsapp_phone", phone)
            .single()
            .execute()
        )
        return result.data if result.data else None
    except Exception as e:
        logger.error(f"Phone lookup failed for {phone}: {e}")
        return None
```

**backend/app/models/message.py** — create Pydantic models for message logging and history:

```python
from pydantic import BaseModel
from datetime import datetime
from typing import Optional
from enum import Enum

class MessageChannel(str, Enum):
    app = "app"
    whatsapp = "whatsapp"

class MessageRole(str, Enum):
    user = "user"
    assistant = "assistant"

class MessageCreate(BaseModel):
    user_id: str
    avatar_id: Optional[str] = None
    channel: MessageChannel
    role: MessageRole
    content: str

class MessageResponse(BaseModel):
    id: str
    user_id: str
    avatar_id: Optional[str]
    channel: MessageChannel
    role: MessageRole
    content: str
    created_at: datetime
```

The `MessageChannel` and `MessageRole` enum values MUST match the DB enums in `backend/migrations/001_initial_schema.sql`.
  </action>
  <verify>
    <automated>cd /c/Users/raphg/Desktop/IA/ava2/backend && python -c "from app.services.whatsapp import send_whatsapp_message; from app.services.user_lookup import lookup_user_by_phone; from app.models.message import MessageCreate; print('services OK')" 2>&1</automated>
    <manual>Check that send_whatsapp_message uses GRAPH_API_VERSION constant (not hardcoded). Check that lookup_user_by_phone uses supabase_admin (not supabase_client). Check that MessageChannel and MessageRole enums match the DB migration.</manual>
  </verify>
  <done>
    - `send_whatsapp_message()` sends via Meta Graph API v19.0 with correct payload structure
    - API version pinned to `GRAPH_API_VERSION = "v19.0"` constant (not hardcoded in URL)
    - `lookup_user_by_phone()` uses `supabase_admin` (service role — correct for webhook context)
    - `MessageCreate` and `MessageResponse` models defined with correct enum types
    - Imports clean — no circular dependencies
  </done>
</task>

<task type="auto">
  <name>Task 2: WhatsApp webhook router and message history endpoint</name>
  <files>
    backend/app/routers/webhook.py
    backend/app/routers/messages.py
  </files>
  <action>
**backend/app/routers/webhook.py** — implement per RESEARCH.md Pattern 4, applying the pitfall fixes from RESEARCH.md Pitfalls 1 and 2:

```python
from fastapi import APIRouter, Request, HTTPException, Query
from app.config import settings
from app.services.whatsapp import send_whatsapp_message
from app.services.user_lookup import lookup_user_by_phone
from app.database import supabase_admin
import logging

router = APIRouter(prefix="/webhook", tags=["webhook"])
logger = logging.getLogger(__name__)
```

**GET /webhook** (verification challenge) — implement exactly as RESEARCH.md Pattern 4:
- Validate `hub.mode == "subscribe"` AND `hub.verify_token == settings.whatsapp_verify_token`
- Return `int(hub_challenge)` on success, raise `HTTPException(403)` on mismatch
- No auth required — this is called by Meta, not by users

**POST /webhook** (incoming message handler):
- Wrap ALL processing in a top-level `try/except Exception as e: logger.error(...)` per RESEARCH.md Pitfall 2
- ALWAYS return `{"status": "ok"}` — even on errors. Meta retries on non-200 responses.
- Parse the payload using the exact nested structure from RESEARCH.md Pattern 4: `body["entry"][0]["changes"][0]["value"]`
- Skip processing if `"messages"` not in value (delivery receipts, status updates)
- Skip processing if `message_type != "text"` (Phase 2: text only)
- Extract `sender_phone = message["from"]` and `phone_number_id = value["metadata"]["phone_number_id"]`
- Call `lookup_user_by_phone(sender_phone)`
- If user is None: send instructions message ("Please create an account at ava.example.com and link your number")
- If user found: send echo `f"[Echo] {incoming_text}"` back via `send_whatsapp_message`
- Log both incoming and outgoing messages to Supabase using `supabase_admin` (not user-scoped — webhook has no user JWT):
  ```python
  supabase_admin.from_("messages").insert([
      {"user_id": user["user_id"], "avatar_id": None, "channel": "whatsapp",
       "role": "user", "content": incoming_text},
      {"user_id": user["user_id"], "avatar_id": None, "channel": "whatsapp",
       "role": "assistant", "content": echo_text},
  ]).execute()
  ```
- Wrap message logging in its own try/except so a DB failure doesn't prevent the echo from being sent

**backend/app/routers/messages.py** — simple authenticated endpoint for message history:

```python
from fastapi import APIRouter, Depends, Query
from app.dependencies import get_current_user, get_authed_supabase
from app.models.message import MessageResponse
from typing import List

router = APIRouter(prefix="/messages", tags=["messages"])

@router.get("", response_model=List[MessageResponse])
async def get_message_history(
    limit: int = Query(50, ge=1, le=200),
    user=Depends(get_current_user),
    db=Depends(get_authed_supabase),
):
    """Returns user's message history, newest first. RLS enforces isolation."""
    result = (
        db.from_("messages")
        .select("*")
        .eq("user_id", str(user.id))
        .order("created_at", desc=True)
        .limit(limit)
        .execute()
    )
    return result.data
```

Register both routers in `backend/app/main.py`:
```python
from app.routers import webhook, messages
app.include_router(webhook.router)
app.include_router(messages.router)
```
  </action>
  <verify>
    <automated>cd /c/Users/raphg/Desktop/IA/ava2/backend && python -c "from app.routers.webhook import router; from app.routers.messages import router as mr; print('webhook and messages routers OK')" 2>&1</automated>
    <manual>Check that POST /webhook has a top-level try/except that returns {"status": "ok"} in all cases. Check that GET /webhook returns int(hub_challenge). Check that message logging uses supabase_admin. Check that GET /messages uses get_authed_supabase (RLS).</manual>
  </verify>
  <done>
    - `GET /webhook` verifies Meta's challenge and returns the challenge integer
    - `GET /webhook` returns 403 on wrong verify token
    - `POST /webhook` always returns `{"status": "ok"}` (200) regardless of internal errors
    - Echo message format is `[Echo] {incoming_text}`
    - Unlinked phone number receives registration instructions
    - Both incoming and outgoing messages logged to Supabase messages table
    - `GET /messages` returns authenticated user's message history (RLS enforced)
    - All routers registered in main.py
  </done>
</task>

</tasks>

<verification>
After both tasks:
1. `python -c "from app.routers.webhook import router; from app.routers.messages import router as mr; print('OK')"` — imports succeed
2. `grep "return {\"status\": \"ok\"}" backend/app/routers/webhook.py` — should find the return statement in the POST handler
3. `grep "try:" backend/app/routers/webhook.py | wc -l` — should show at least 1 top-level try block
4. `grep "supabase_admin" backend/app/services/user_lookup.py` — should match (correct client)
5. `grep "get_authed_supabase" backend/app/routers/messages.py` — should match (RLS enforced)
</verification>

<success_criteria>
- Meta webhook verification: GET /webhook with correct verify_token returns the challenge integer
- Meta webhook verification: GET /webhook with wrong verify_token returns 403
- POST /webhook always returns 200 (never causes Meta retries from error responses)
- A text message from a linked WhatsApp number triggers an echo response
- Message logging records both user and assistant messages in the messages table
- GET /messages returns only the authenticated user's messages (RLS isolation)
</success_criteria>

<output>
After completion, create `.planning/phases/02-infrastructure-user-management/02-04-SUMMARY.md`
</output>
