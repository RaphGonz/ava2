---
phase: 02-infrastructure-user-management
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - backend/app/routers/auth.py
  - backend/app/models/auth.py
  - backend/templates/auth.html
autonomous: true
requirements: [USER-01]

must_haves:
  truths:
    - "User can POST /auth/signup with email + password and receive a JWT access token immediately"
    - "User can POST /auth/signin with correct credentials and receive a JWT access token"
    - "POST /auth/signin with wrong password returns HTTP 401"
    - "The minimal HTML test UI at /dev/auth allows signup and signin via browser forms"
    - "Signup returns a token that can be used as Bearer auth on protected endpoints"
  artifacts:
    - path: "backend/app/routers/auth.py"
      provides: "POST /auth/signup and POST /auth/signin endpoints"
      exports: ["router"]
    - path: "backend/app/models/auth.py"
      provides: "SignupRequest, SigninRequest, TokenResponse Pydantic models"
      contains: "class TokenResponse"
    - path: "backend/templates/auth.html"
      provides: "Barebones HTML form for signup and signin (no styling)"
      contains: "fetch('/auth/signup'"
  key_links:
    - from: "backend/templates/auth.html"
      to: "backend/app/routers/auth.py"
      via: "fetch POST /auth/signup and /auth/signin"
      pattern: "fetch\\('/auth/(signup|signin)'"
    - from: "backend/app/routers/auth.py"
      to: "backend/app/database.py"
      via: "supabase_client.auth.sign_up / sign_in_with_password"
      pattern: "supabase_client\\.auth\\.(sign_up|sign_in_with_password)"
---

<objective>
Implement the email/password auth API (signup + signin) and the minimal barebones HTML test UI that proves auth works end-to-end in a browser.

Purpose: USER-01 (user can create an account) is the gateway requirement. Without auth, avatar creation (Plan 03) and protected routes cannot be tested.

Output:
- `POST /auth/signup` — creates Supabase user, returns JWT
- `POST /auth/signin` — authenticates user, returns JWT
- `GET /dev/auth` — serves barebones HTML form (no styling, dev-only route)
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/02-infrastructure-user-management/02-CONTEXT.md
@.planning/phases/02-infrastructure-user-management/02-RESEARCH.md
@.planning/phases/02-infrastructure-user-management/02-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Auth Pydantic models and signup/signin router</name>
  <files>
    backend/app/models/auth.py
    backend/app/routers/auth.py
  </files>
  <action>
**backend/app/models/auth.py** — create three Pydantic models:

```python
from pydantic import BaseModel, EmailStr

class SignupRequest(BaseModel):
    email: EmailStr
    password: str  # Supabase enforces min 6 chars

class SigninRequest(BaseModel):
    email: EmailStr
    password: str

class TokenResponse(BaseModel):
    access_token: str
    user_id: str
```

Note: `EmailStr` requires `pydantic[email]` — add `pydantic[email]` to requirements.txt if not already present.

**backend/app/routers/auth.py** — implement exactly as RESEARCH.md Pattern 1:

- `POST /auth/signup` using `supabase_client.auth.sign_up()`. On success return `TokenResponse`. On failure raise `HTTPException(400, str(e))`.
- `POST /auth/signin` using `supabase_client.auth.sign_in_with_password()`. On success return `TokenResponse`. On wrong credentials raise `HTTPException(401, "Invalid credentials")`.

IMPORTANT: The Supabase `sign_up` call may return `session=None` if email confirmation is enabled. Add a guard: `if response.session is None: raise HTTPException(400, "Email confirmation required — disable it in Supabase Dashboard > Authentication > Providers > Email")`. This surfaces the misconfiguration clearly instead of a cryptic AttributeError.

Register this router in `backend/app/main.py` with `app.include_router(auth.router)`.
  </action>
  <verify>
    <automated>cd /c/Users/raphg/Desktop/IA/ava2/backend && python -c "from app.routers.auth import router; print('auth router OK')" 2>&1</automated>
    <manual>Check that POST /auth/signup and POST /auth/signin are defined. Check that the session=None guard is present. Check that router is included in main.py.</manual>
  </verify>
  <done>
    - `backend/app/models/auth.py` defines SignupRequest, SigninRequest, TokenResponse
    - `backend/app/routers/auth.py` defines POST /auth/signup and POST /auth/signin
    - Auth router registered in main.py
    - Wrong credentials return 401, not 500
    - session=None guard gives clear misconfiguration message
  </done>
</task>

<task type="auto">
  <name>Task 2: Minimal barebones HTML test UI served by FastAPI</name>
  <files>
    backend/templates/auth.html
    backend/app/routers/dev.py
  </files>
  <action>
The Phase 2 UI is intentionally minimal — barebones HTML forms, no CSS styling, no JavaScript framework. Its only purpose is to prove that signup and signin work in a browser. Per user decision in CONTEXT.md: "No styling — that's Phase 6."

**backend/templates/auth.html** — implement exactly as RESEARCH.md Code Examples (Minimal Auth Test UI), extending it with:
1. Signup form (email + password → POST /auth/signup)
2. Signin form (email + password → POST /auth/signin)
3. A `<p id="result">` that shows the truncated token on success or the error message on failure
4. After successful signin, also display the user_id
5. Add a link: `<a href="/dev/avatars">Avatar Setup</a>` (for navigation to Plan 03's dev page)
6. Include inline JavaScript only (no external scripts). No CDN links. Works offline.

Display the token response as: `Signed up! user_id={data.user_id}, token starts with: {data.access_token.substring(0,20)}...`

**backend/app/routers/dev.py** — create a dev router with:
- `GET /dev/auth` — returns `HTMLResponse` from `templates/auth.html`. Use `fastapi.responses.HTMLResponse` and read the file content. Only active when `settings.app_env == "development"` (raise 404 in production).

Register `dev.router` in `backend/app/main.py`.

Use `pathlib.Path` to locate the templates directory relative to the routers file (not hardcoded absolute paths).
  </action>
  <verify>
    <automated>grep -c "fetch('/auth/signup'" /c/Users/raphg/Desktop/IA/ava2/backend/templates/auth.html && grep "fetch('/auth/signin'" /c/Users/raphg/Desktop/IA/ava2/backend/templates/auth.html</automated>
    <manual>Confirm templates/auth.html has no external CSS or JS imports. Confirm dev.py only serves the page when app_env=development. Confirm dev router is included in main.py.</manual>
  </verify>
  <done>
    - `backend/templates/auth.html` exists with signup and signin forms
    - Both forms call the correct API endpoints via fetch
    - Result element shows token or error message
    - `GET /dev/auth` serves the HTML in development mode, returns 404 in production
    - No external dependencies in the HTML file
  </done>
</task>

</tasks>

<verification>
After both tasks:
1. `python -c "from app.routers.auth import router; from app.routers.dev import router as dev; print('OK')"` — should print OK
2. `grep "POST /auth/signup\|post.*signup\|@router.post.*signup" backend/app/routers/auth.py` — should match
3. `grep "session is None" backend/app/routers/auth.py` — should find the guard
4. `cat backend/templates/auth.html | grep "fetch"` — should show both fetch calls
</verification>

<success_criteria>
- `POST /auth/signup` with valid email/password returns 200 with `{access_token, user_id}`
- `POST /auth/signin` with valid credentials returns 200 with `{access_token, user_id}`
- `POST /auth/signin` with wrong password returns 401
- `GET /dev/auth` returns HTML page in development mode
- No external CSS/JS dependencies in the HTML test UI
</success_criteria>

<output>
After completion, create `.planning/phases/02-infrastructure-user-management/02-02-SUMMARY.md`
</output>
