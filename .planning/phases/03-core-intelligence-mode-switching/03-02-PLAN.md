---
phase: 03-core-intelligence-mode-switching
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - backend/app/services/session/__init__.py
  - backend/app/services/session/models.py
  - backend/app/services/session/store.py
  - backend/app/services/mode_detection/__init__.py
  - backend/app/services/mode_detection/detector.py
  - backend/tests/__init__.py
  - backend/tests/test_mode_detection.py
  - backend/tests/test_session_store.py
autonomous: true
requirements: [CHAT-02, CHAT-03, CHAT-04, CHAT-05]

must_haves:
  truths:
    - "ConversationMode enum has SECRETARY and INTIMATE values"
    - "SessionStore maintains separate message histories per (user_id, mode) pair — histories never cross mode boundaries"
    - "ModeSwitchDetector returns 'exact' confidence for /intimate, /secretary, /stop slash commands"
    - "ModeSwitchDetector returns 'fuzzy' confidence for phrase matches scoring >= 75 (e.g., 'im alone', 'lets stop')"
    - "ModeSwitchDetector returns 'ambiguous' confidence for scores in [50, 75) range"
    - "ModeSwitchDetector returns confidence='none' for normal chat messages"
    - "SessionStore.append_message() silently drops oldest messages when MAX_HISTORY_MESSAGES is exceeded"
    - "All session mutations are protected by asyncio.Lock — concurrent calls do not corrupt state"
  artifacts:
    - path: "backend/app/services/session/models.py"
      provides: "ConversationMode enum and Message type alias"
      exports: ["ConversationMode", "Message"]
    - path: "backend/app/services/session/store.py"
      provides: "SessionStore with asyncio-safe per-user per-mode history"
      exports: ["SessionStore", "SessionState", "get_session_store"]
    - path: "backend/app/services/mode_detection/detector.py"
      provides: "detect_mode_switch() function with slash commands + fuzzy phrase detection"
      exports: ["DetectionResult", "detect_mode_switch"]
    - path: "backend/tests/test_mode_detection.py"
      provides: "Pytest tests for all DetectionResult confidence levels and edge cases"
    - path: "backend/tests/test_session_store.py"
      provides: "Pytest tests for SessionStore history isolation, overflow, and reset"
  key_links:
    - from: "backend/app/services/mode_detection/detector.py"
      to: "rapidfuzz"
      via: "process.extractOne with fuzz.token_set_ratio"
      pattern: "token_set_ratio"
    - from: "backend/app/services/session/store.py"
      to: "asyncio"
      via: "asyncio.Lock()"
      pattern: "asyncio\\.Lock"
---

<objective>
Build and TDD-verify session state management and mode switch detection: ConversationMode enum, SessionState dataclass, SessionStore with asyncio-safe per-user/per-mode history, and ModeSwitchDetector with slash command + fuzzy phrase detection.

Purpose: CHAT-02 through CHAT-05 require that conversations persist within a session, mode switches are detected reliably (exact and fuzzy), and mode histories stay isolated. TDD ensures the detection thresholds and history isolation invariants are correct before wiring into the webhook.
Output: Two new service packages (session/, mode_detection/) and their corresponding test files.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/03-core-intelligence-mode-switching/03-CONTEXT.md
@.planning/phases/03-core-intelligence-mode-switching/03-RESEARCH.md
</context>

<feature>
  <name>Session state and mode switch detection</name>
  <files>
    backend/app/services/session/models.py,
    backend/app/services/session/store.py,
    backend/app/services/mode_detection/detector.py,
    backend/tests/test_mode_detection.py,
    backend/tests/test_session_store.py
  </files>
  <behavior>
**ModeSwitchDetector test cases:**

| Input | Expected target | Expected confidence |
|-------|----------------|---------------------|
| `/intimate` | INTIMATE | exact |
| `/secretary` | SECRETARY | exact |
| `/stop` | SECRETARY | exact |
| `i'm alone` | INTIMATE | fuzzy |
| `im alone` (typo) | INTIMATE | fuzzy |
| `lets be alone` | INTIMATE | fuzzy |
| `stop` | SECRETARY | fuzzy |
| `back to work` | SECRETARY | fuzzy |
| `Hello, how are you?` | None | none |
| `What's the weather today?` | None | none |
| `I'm done with the project analysis` (long sentence with "stop" word) | None | none (>10 words guard) |

**SessionStore test cases:**

| Scenario | Expected behavior |
|----------|------------------|
| New user get_or_create | Returns empty SessionState with mode=SECRETARY |
| append_message SECRETARY | Message appears in SECRETARY history only |
| append_message INTIMATE | Message appears in INTIMATE history only (SECRETARY unchanged) |
| switch_mode to INTIMATE | State.mode becomes INTIMATE; histories preserved |
| Overflow: append 45 messages | History length stays <= MAX_HISTORY_MESSAGES (40) |
| reset_session | All history cleared, mode reset to SECRETARY |
  </behavior>
  <implementation>
**RED phase (write tests first, confirm they fail):**

Create `backend/tests/__init__.py` (empty).

Create `backend/tests/test_mode_detection.py` with the test cases above. Import `detect_mode_switch` and `DetectionResult` from `app.services.mode_detection.detector`. All tests should fail because the module doesn't exist yet.

Create `backend/tests/test_session_store.py` with the SessionStore test cases. Import from `app.services.session.store`. Use `pytest.mark.asyncio` for async tests.

**GREEN phase (implement to pass):**

Create `backend/app/services/session/` package:

**`models.py`:**
```python
from enum import Enum

class ConversationMode(str, Enum):
    SECRETARY = "secretary"
    INTIMATE = "intimate"

Message = dict  # {"role": "user"|"assistant", "content": str}
```

**`store.py`:**
```python
import asyncio
from dataclasses import dataclass, field
from app.services.session.models import ConversationMode, Message


@dataclass
class SessionState:
    mode: ConversationMode = ConversationMode.SECRETARY
    history: dict = field(
        default_factory=lambda: {
            ConversationMode.SECRETARY: [],
            ConversationMode.INTIMATE: [],
        }
    )
    pending_switch_to: ConversationMode | None = None  # clarification gate


class SessionStore:
    """In-memory per-user conversation state. asyncio.Lock guards all mutations."""

    MAX_HISTORY_MESSAGES = 40  # silently drop oldest when exceeded

    def __init__(self):
        self._sessions: dict[str, SessionState] = {}
        self._lock = asyncio.Lock()

    async def get_or_create(self, user_id: str) -> SessionState:
        async with self._lock:
            if user_id not in self._sessions:
                self._sessions[user_id] = SessionState()
            return self._sessions[user_id]

    async def append_message(self, user_id: str, mode: ConversationMode, message: Message) -> None:
        async with self._lock:
            state = self._sessions.setdefault(user_id, SessionState())
            history = state.history[mode]
            history.append(message)
            if len(history) > self.MAX_HISTORY_MESSAGES:
                excess = len(history) - self.MAX_HISTORY_MESSAGES
                state.history[mode] = history[excess:]

    async def switch_mode(self, user_id: str, new_mode: ConversationMode) -> None:
        async with self._lock:
            state = self._sessions.setdefault(user_id, SessionState())
            state.mode = new_mode
            state.pending_switch_to = None

    async def reset_session(self, user_id: str) -> None:
        async with self._lock:
            self._sessions[user_id] = SessionState()


# Module-level singleton — shared across all requests in a single process
# IMPORTANT: Requires --workers 1 (single uvicorn process). Multi-worker needs Redis upgrade.
_session_store: SessionStore | None = None


def get_session_store() -> SessionStore:
    global _session_store
    if _session_store is None:
        _session_store = SessionStore()
    return _session_store
```

Create `backend/app/services/mode_detection/` package:

**`detector.py`** — implement using `rapidfuzz`:
- Slash command dict maps `/intimate`, `/secretary`, `/stop` → ConversationMode
- INTIMATE_PHRASES and SECRETARY_PHRASES lists from RESEARCH.md (8 phrases each)
- FUZZY_THRESHOLD = 75, AMBIGUOUS_THRESHOLD = 50
- Long message guard: if len(stripped.split()) > 10, only match slash commands (prevents "stop" firing in long sentences)
- `DetectionResult` dataclass with `target: ConversationMode | None` and `confidence: str`
- `detect_mode_switch(text: str, current_mode: ConversationMode) -> DetectionResult`

**REFACTOR phase (if needed):**
Clean up any duplication. Ensure phrase lists are easy to extend. Add docstrings.
  </implementation>
</feature>

<tasks>

<task type="auto">
  <name>Task 1 (RED): Write failing tests for ModeSwitchDetector and SessionStore</name>
  <files>
    backend/tests/__init__.py
    backend/tests/test_mode_detection.py
    backend/tests/test_session_store.py
  </files>
  <action>
Create `backend/tests/` directory if it doesn't exist.

**`backend/tests/__init__.py`** — empty file.

**`backend/tests/test_mode_detection.py`** — full test suite:

```python
"""Tests for ModeSwitchDetector — slash commands, fuzzy phrases, and edge cases."""
import pytest
from app.services.mode_detection.detector import detect_mode_switch, DetectionResult
from app.services.session.models import ConversationMode


class TestSlashCommands:
    """Exact slash command detection must always be confidence='exact'."""

    def test_intimate_slash(self):
        result = detect_mode_switch("/intimate", ConversationMode.SECRETARY)
        assert result.target == ConversationMode.INTIMATE
        assert result.confidence == "exact"

    def test_secretary_slash(self):
        result = detect_mode_switch("/secretary", ConversationMode.INTIMATE)
        assert result.target == ConversationMode.SECRETARY
        assert result.confidence == "exact"

    def test_stop_slash(self):
        result = detect_mode_switch("/stop", ConversationMode.INTIMATE)
        assert result.target == ConversationMode.SECRETARY
        assert result.confidence == "exact"

    def test_slash_with_leading_space(self):
        result = detect_mode_switch("  /intimate  ", ConversationMode.SECRETARY)
        assert result.confidence == "exact"


class TestFuzzyIntimateDetection:
    """Fuzzy match for intimate mode triggers."""

    def test_im_alone_exact_phrase(self):
        result = detect_mode_switch("i'm alone", ConversationMode.SECRETARY)
        assert result.target == ConversationMode.INTIMATE
        assert result.confidence == "fuzzy"

    def test_im_alone_typo(self):
        result = detect_mode_switch("im alone", ConversationMode.SECRETARY)
        assert result.target == ConversationMode.INTIMATE
        assert result.confidence in ("exact", "fuzzy")  # high confidence either way

    def test_lets_be_alone(self):
        result = detect_mode_switch("lets be alone", ConversationMode.SECRETARY)
        assert result.target == ConversationMode.INTIMATE
        assert result.confidence == "fuzzy"


class TestFuzzySecretaryDetection:
    """Fuzzy match for secretary mode triggers."""

    def test_stop(self):
        result = detect_mode_switch("stop", ConversationMode.INTIMATE)
        assert result.target == ConversationMode.SECRETARY
        assert result.confidence == "fuzzy"

    def test_back_to_work(self):
        result = detect_mode_switch("back to work", ConversationMode.INTIMATE)
        assert result.target == ConversationMode.SECRETARY
        assert result.confidence == "fuzzy"


class TestNormalMessages:
    """Normal chat messages must not be misclassified as mode switches."""

    def test_greeting(self):
        result = detect_mode_switch("Hello, how are you?", ConversationMode.SECRETARY)
        assert result.confidence == "none"
        assert result.target is None

    def test_weather_question(self):
        result = detect_mode_switch("What's the weather today?", ConversationMode.SECRETARY)
        assert result.confidence == "none"

    def test_long_sentence_with_stop_word(self):
        # "stop" alone is a trigger, but in a long sentence it should not fire
        result = detect_mode_switch(
            "I'm done and want to stop the project analysis right now",
            ConversationMode.INTIMATE,
        )
        assert result.confidence == "none", (
            "Long sentences with trigger words should not fire mode switch"
        )
```

**`backend/tests/test_session_store.py`** — full test suite:

```python
"""Tests for SessionStore — history isolation, overflow, and reset."""
import pytest
from app.services.session.store import SessionStore, SessionState
from app.services.session.models import ConversationMode


@pytest.fixture
def store():
    return SessionStore()


class TestSessionCreation:
    @pytest.mark.asyncio
    async def test_new_user_gets_empty_state(self, store):
        state = await store.get_or_create("user-123")
        assert state.mode == ConversationMode.SECRETARY
        assert state.history[ConversationMode.SECRETARY] == []
        assert state.history[ConversationMode.INTIMATE] == []

    @pytest.mark.asyncio
    async def test_same_user_returns_same_state(self, store):
        state1 = await store.get_or_create("user-abc")
        state2 = await store.get_or_create("user-abc")
        assert state1 is state2


class TestHistoryIsolation:
    @pytest.mark.asyncio
    async def test_secretary_message_stays_in_secretary(self, store):
        msg = {"role": "user", "content": "Hello"}
        await store.append_message("user-1", ConversationMode.SECRETARY, msg)
        state = await store.get_or_create("user-1")
        assert len(state.history[ConversationMode.SECRETARY]) == 1
        assert len(state.history[ConversationMode.INTIMATE]) == 0

    @pytest.mark.asyncio
    async def test_intimate_message_stays_in_intimate(self, store):
        msg = {"role": "user", "content": "Private message"}
        await store.append_message("user-2", ConversationMode.INTIMATE, msg)
        state = await store.get_or_create("user-2")
        assert len(state.history[ConversationMode.INTIMATE]) == 1
        assert len(state.history[ConversationMode.SECRETARY]) == 0


class TestHistoryOverflow:
    @pytest.mark.asyncio
    async def test_overflow_drops_oldest_messages(self, store):
        for i in range(45):
            await store.append_message(
                "user-overflow",
                ConversationMode.SECRETARY,
                {"role": "user", "content": f"Message {i}"},
            )
        state = await store.get_or_create("user-overflow")
        history = state.history[ConversationMode.SECRETARY]
        assert len(history) <= SessionStore.MAX_HISTORY_MESSAGES
        # Newest messages should be retained
        assert history[-1]["content"] == "Message 44"


class TestModeSwitch:
    @pytest.mark.asyncio
    async def test_switch_changes_mode(self, store):
        await store.switch_mode("user-3", ConversationMode.INTIMATE)
        state = await store.get_or_create("user-3")
        assert state.mode == ConversationMode.INTIMATE

    @pytest.mark.asyncio
    async def test_switch_clears_pending(self, store):
        state = await store.get_or_create("user-4")
        state.pending_switch_to = ConversationMode.INTIMATE  # simulate pending
        await store.switch_mode("user-4", ConversationMode.INTIMATE)
        state = await store.get_or_create("user-4")
        assert state.pending_switch_to is None


class TestSessionReset:
    @pytest.mark.asyncio
    async def test_reset_clears_all_history(self, store):
        await store.append_message(
            "user-5", ConversationMode.SECRETARY, {"role": "user", "content": "Hi"}
        )
        await store.reset_session("user-5")
        state = await store.get_or_create("user-5")
        assert state.history[ConversationMode.SECRETARY] == []
        assert state.mode == ConversationMode.SECRETARY
```

Run tests to confirm they FAIL (modules not yet created):
```bash
cd backend && python -m pytest tests/test_mode_detection.py tests/test_session_store.py -x 2>&1 | head -30
```

Commit: `test(03-02): add failing tests for mode detection and session store`
  </action>
  <verify>
    <automated>cd backend && python -m pytest tests/test_mode_detection.py tests/test_session_store.py 2>&1 | grep -E "(FAILED|ERROR|error)" | head -10</automated>
    <manual>Tests should fail with ModuleNotFoundError — that confirms the RED phase is correct. If tests pass, the implementation already exists (check for existing files).</manual>
  </verify>
  <done>Test files exist. Running pytest produces failures (import errors or assertion failures). RED phase confirmed.</done>
</task>

<task type="auto">
  <name>Task 2 (GREEN + REFACTOR): Implement session models, SessionStore, and ModeSwitchDetector until all tests pass</name>
  <files>
    backend/app/services/session/__init__.py
    backend/app/services/session/models.py
    backend/app/services/session/store.py
    backend/app/services/mode_detection/__init__.py
    backend/app/services/mode_detection/detector.py
  </files>
  <action>
Create both packages and run tests after each file until all pass.

**`backend/app/services/session/__init__.py`** — empty.

**`backend/app/services/session/models.py`:**
```python
from enum import Enum

class ConversationMode(str, Enum):
    SECRETARY = "secretary"
    INTIMATE = "intimate"

Message = dict  # {"role": "user"|"assistant", "content": str}
```

**`backend/app/services/session/store.py`:**
```python
import asyncio
from dataclasses import dataclass, field
from app.services.session.models import ConversationMode, Message


@dataclass
class SessionState:
    mode: ConversationMode = ConversationMode.SECRETARY
    history: dict = field(
        default_factory=lambda: {
            ConversationMode.SECRETARY: [],
            ConversationMode.INTIMATE: [],
        }
    )
    pending_switch_to: ConversationMode | None = None


class SessionStore:
    """In-memory per-user conversation state. asyncio.Lock guards all mutations.

    WARNING: In-memory only. Requires single uvicorn worker (--workers 1).
    Multi-worker deployments need a Redis-backed SessionStore implementation.
    """

    MAX_HISTORY_MESSAGES = 40  # silently drop oldest; context window overflow strategy

    def __init__(self):
        self._sessions: dict[str, SessionState] = {}
        self._lock = asyncio.Lock()

    async def get_or_create(self, user_id: str) -> SessionState:
        async with self._lock:
            if user_id not in self._sessions:
                self._sessions[user_id] = SessionState()
            return self._sessions[user_id]

    async def append_message(self, user_id: str, mode: ConversationMode, message: Message) -> None:
        async with self._lock:
            state = self._sessions.setdefault(user_id, SessionState())
            history = state.history[mode]
            history.append(message)
            if len(history) > self.MAX_HISTORY_MESSAGES:
                excess = len(history) - self.MAX_HISTORY_MESSAGES
                state.history[mode] = history[excess:]

    async def switch_mode(self, user_id: str, new_mode: ConversationMode) -> None:
        """Switch mode. Clears pending_switch_to. History per mode preserved."""
        async with self._lock:
            state = self._sessions.setdefault(user_id, SessionState())
            state.mode = new_mode
            state.pending_switch_to = None

    async def reset_session(self, user_id: str) -> None:
        """Explicit reset — clears all history and returns to SECRETARY mode."""
        async with self._lock:
            self._sessions[user_id] = SessionState()


_session_store: SessionStore | None = None


def get_session_store() -> SessionStore:
    """Module-level singleton getter. One store per process."""
    global _session_store
    if _session_store is None:
        _session_store = SessionStore()
    return _session_store
```

**`backend/app/services/mode_detection/__init__.py`** — empty.

**`backend/app/services/mode_detection/detector.py`:**
```python
from dataclasses import dataclass
from rapidfuzz import process, fuzz
from app.services.session.models import ConversationMode

# Extend these lists to add new trigger phrases without touching detection logic
INTIMATE_PHRASES = [
    "i'm alone", "im alone", "let's be alone", "lets be alone",
    "private", "i am alone", "just us", "we're alone", "were alone",
]
SECRETARY_PHRASES = [
    "stop", "back to work", "secretary mode", "work mode",
    "that's enough", "thats enough", "let's stop", "lets stop",
]
SLASH_COMMANDS: dict[str, ConversationMode] = {
    "/intimate": ConversationMode.INTIMATE,
    "/secretary": ConversationMode.SECRETARY,
    "/stop": ConversationMode.SECRETARY,
}

FUZZY_THRESHOLD = 75    # score >= this: confident match, confirm before switching
AMBIGUOUS_THRESHOLD = 50  # score in [50, 75): ambiguous, ask for clarification
MAX_WORDS_FOR_FUZZY = 10  # guard: long sentences with trigger words should not fire


@dataclass
class DetectionResult:
    target: ConversationMode | None  # None = not a mode switch attempt
    confidence: str                   # "exact" | "fuzzy" | "ambiguous" | "none"


def detect_mode_switch(text: str, current_mode: ConversationMode) -> DetectionResult:
    """
    Classify incoming text as a mode switch request or normal message.

    Detection order:
    1. Exact slash command match (highest confidence, survives typos in phrasing)
    2. Fuzzy phrase match via rapidfuzz token_set_ratio (handles natural language)
    3. Long message guard: skip fuzzy for messages > MAX_WORDS_FOR_FUZZY words

    Returns:
        DetectionResult with:
        - confidence="exact"    → slash command, act immediately
        - confidence="fuzzy"    → score >= FUZZY_THRESHOLD, confirm before switching
        - confidence="ambiguous"→ score in [AMBIGUOUS_THRESHOLD, FUZZY_THRESHOLD), clarify
        - confidence="none"     → normal message, route to LLM
    """
    stripped = text.strip().lower()

    # Stage 1: Exact slash command (immune to message length)
    if stripped in SLASH_COMMANDS:
        return DetectionResult(target=SLASH_COMMANDS[stripped], confidence="exact")

    # Stage 2: Long message guard — only slash commands match for long inputs
    word_count = len(stripped.split())
    if word_count > MAX_WORDS_FOR_FUZZY:
        return DetectionResult(target=None, confidence="none")

    # Stage 3: Fuzzy phrase match
    intimate_match = process.extractOne(stripped, INTIMATE_PHRASES, scorer=fuzz.token_set_ratio)
    secretary_match = process.extractOne(stripped, SECRETARY_PHRASES, scorer=fuzz.token_set_ratio)

    best_target: ConversationMode | None = None
    best_score = 0
    if intimate_match and intimate_match[1] > best_score:
        best_score = intimate_match[1]
        best_target = ConversationMode.INTIMATE
    if secretary_match and secretary_match[1] > best_score:
        best_score = secretary_match[1]
        best_target = ConversationMode.SECRETARY

    if best_score >= FUZZY_THRESHOLD:
        return DetectionResult(target=best_target, confidence="fuzzy")
    if best_score >= AMBIGUOUS_THRESHOLD:
        return DetectionResult(target=best_target, confidence="ambiguous")

    return DetectionResult(target=None, confidence="none")
```

Run tests to confirm GREEN:
```bash
cd backend && python -m pytest tests/test_mode_detection.py tests/test_session_store.py -v 2>&1
```

If any test fails, fix the implementation (not the tests) until all pass.

Commit: `feat(03-02): implement session store and mode switch detector`
  </action>
  <verify>
    <automated>cd backend && python -m pytest tests/test_mode_detection.py tests/test_session_store.py -v 2>&1 | tail -20</automated>
    <manual>All tests should show PASSED. Confirm no tests were skipped. Confirm long-sentence test passes (no false positive for "I'm done and want to stop the project analysis right now").</manual>
  </verify>
  <done>All tests in test_mode_detection.py and test_session_store.py pass. Both service packages exist and pass py_compile. get_session_store() singleton function exists in store.py.</done>
</task>

</tasks>

<verification>
`cd backend && python -m pytest tests/ -v` — all tests pass.
`python -m py_compile backend/app/services/session/models.py` — clean.
`python -m py_compile backend/app/services/session/store.py` — clean.
`python -m py_compile backend/app/services/mode_detection/detector.py` — clean.
Grep for `asyncio.Lock` in store.py confirms concurrency safety.
Grep for `token_set_ratio` in detector.py confirms fuzzy scorer used.
</verification>

<success_criteria>
- All tests in test_mode_detection.py and test_session_store.py pass
- /intimate → exact confidence; /stop → exact confidence
- "im alone" → fuzzy confidence, INTIMATE target
- "I'm done and want to stop the project analysis right now" → none confidence (long message guard)
- SessionStore.append_message() keeps history <= MAX_HISTORY_MESSAGES
- Secretary and intimate histories are independent lists (append to one does not affect other)
- get_session_store() returns same singleton instance across calls
</success_criteria>

<output>
After completion, create `.planning/phases/03-core-intelligence-mode-switching/03-02-SUMMARY.md`
</output>
