---
phase: 06-web-app-multi-platform
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/package.json
  - frontend/vite.config.ts
  - frontend/index.html
  - frontend/src/main.tsx
  - frontend/src/App.tsx
  - frontend/src/store/useAuthStore.ts
  - frontend/src/api/auth.ts
  - frontend/src/api/chat.ts
  - frontend/src/api/preferences.ts
  - frontend/src/pages/LoginPage.tsx
autonomous: true
requirements:
  - PLAT-02

must_haves:
  truths:
    - "React + Vite + Tailwind CSS frontend scaffold exists at frontend/"
    - "Zustand auth store persists JWT token and user_id to localStorage"
    - "API client modules exist for auth, chat, and preferences"
    - "LoginPage renders and allows email/password sign-in via existing /auth/signin endpoint"
    - "App.tsx routes between LoginPage and authenticated views using react-router-dom"
  artifacts:
    - path: "frontend/package.json"
      provides: "Frontend dependencies including React 19, Vite 6, Tailwind 4, Zustand, TanStack Query, react-router-dom"
      contains: "react-router-dom"
    - path: "frontend/src/store/useAuthStore.ts"
      provides: "Zustand store with persist middleware for JWT and user_id"
      exports: ["useAuthStore"]
    - path: "frontend/src/App.tsx"
      provides: "Root router with protected and public routes"
      min_lines: 20
    - path: "frontend/src/pages/LoginPage.tsx"
      provides: "Email/password login form wired to /auth/signin API"
      min_lines: 30
  key_links:
    - from: "frontend/src/store/useAuthStore.ts"
      to: "localStorage"
      via: "zustand/middleware persist"
      pattern: "persist"
    - from: "frontend/src/pages/LoginPage.tsx"
      to: "frontend/src/api/auth.ts"
      via: "signIn() call"
      pattern: "signIn"
    - from: "frontend/src/App.tsx"
      to: "frontend/src/pages/LoginPage.tsx"
      via: "react-router-dom Route"
      pattern: "Route.*LoginPage"
---

<objective>
Scaffold the React + Vite + Tailwind CSS frontend application with authentication foundation.

Purpose: Establish the frontend project structure that all subsequent UI plans build on. The auth store, API client modules, and routing structure must be in place before chat UI and settings UI can be built.
Output: frontend/ directory with working npm dev server, LoginPage, and Zustand auth store.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/06-web-app-multi-platform/06-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Scaffold Vite + React + Tailwind frontend project</name>
  <files>
    frontend/package.json
    frontend/vite.config.ts
    frontend/index.html
    frontend/src/main.tsx
    frontend/src/App.tsx
  </files>
  <action>
Create a new React + TypeScript + Tailwind frontend project in the `frontend/` directory at the repo root (alongside `backend/`).

**Step 1 — Create Vite project:**
Run in the repo root:
```bash
npm create vite@latest frontend -- --template react-ts --yes
```
This produces: frontend/package.json, frontend/vite.config.ts, frontend/index.html, frontend/src/main.tsx, frontend/src/App.tsx, and supporting files.

**Step 2 — Install dependencies:**
```bash
cd frontend
npm install react-router-dom @tanstack/react-query zustand
npm install -D tailwindcss @tailwindcss/vite
```

Do NOT install @supabase/supabase-js — auth is done via the FastAPI backend, not directly to Supabase JS SDK from the frontend.

**Step 3 — Configure Tailwind v4:**
Tailwind v4 uses a CSS-based config (no tailwind.config.js). Update `frontend/vite.config.ts`:
```typescript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import tailwindcss from '@tailwindcss/vite'

export default defineConfig({
  plugins: [
    react(),
    tailwindcss(),
  ],
  server: {
    port: 3000,
    proxy: {
      // Proxy API calls to FastAPI backend (avoids CORS in dev)
      '/auth': 'http://localhost:8000',
      '/chat': 'http://localhost:8000',
      '/preferences': 'http://localhost:8000',
      '/avatars': 'http://localhost:8000',
      '/photos': 'http://localhost:8000',
    },
  },
})
```

Add Tailwind import to `frontend/src/index.css` (replace entire file):
```css
@import "tailwindcss";
```

**Step 4 — Update App.tsx with react-router-dom routing:**
Replace the generated App.tsx with:
```tsx
import { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { useAuthStore } from './store/useAuthStore'
import LoginPage from './pages/LoginPage'
import ChatPage from './pages/ChatPage'
import SettingsPage from './pages/SettingsPage'
import PhotoPage from './pages/PhotoPage'

const queryClient = new QueryClient()

function ProtectedRoute({ children }: { children: React.ReactNode }) {
  const token = useAuthStore(s => s.token)
  if (!token) return <Navigate to="/login" replace />
  return <>{children}</>
}

export default function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <BrowserRouter>
        <Routes>
          <Route path="/login" element={<LoginPage />} />
          <Route path="/chat" element={<ProtectedRoute><ChatPage /></ProtectedRoute>} />
          <Route path="/settings" element={<ProtectedRoute><SettingsPage /></ProtectedRoute>} />
          <Route path="/photo" element={<PhotoPage />} />
          <Route path="*" element={<Navigate to="/chat" replace />} />
        </Routes>
      </BrowserRouter>
    </QueryClientProvider>
  )
}
```

Create stub page files so App.tsx compiles (full implementation comes in Plans 04 and 05):
- `frontend/src/pages/ChatPage.tsx` — `export default function ChatPage() { return <div className="p-4">Chat coming soon</div> }`
- `frontend/src/pages/SettingsPage.tsx` — `export default function SettingsPage() { return <div className="p-4">Settings coming soon</div> }`
- `frontend/src/pages/PhotoPage.tsx` — `export default function PhotoPage() { return <div className="p-4">Photo viewer</div> }`
  </action>
  <verify>
    <automated>cd /c/Users/raphg/Desktop/IA/ava2/frontend && npm run build 2>&1 | tail -5</automated>
    <manual>Confirm build output shows no TypeScript errors and dist/ is created.</manual>
  </verify>
  <done>
    frontend/ directory exists with package.json, vite.config.ts with proxy config, index.html, and src/. `npm run build` completes without errors. Stub pages exist for ChatPage, SettingsPage, PhotoPage.
  </done>
</task>

<task type="auto">
  <name>Task 2: Zustand auth store, API clients, and LoginPage</name>
  <files>
    frontend/src/store/useAuthStore.ts
    frontend/src/api/auth.ts
    frontend/src/api/chat.ts
    frontend/src/api/preferences.ts
    frontend/src/pages/LoginPage.tsx
  </files>
  <action>
Create the auth store, API client modules, and LoginPage.

**frontend/src/store/useAuthStore.ts:**
```typescript
import { create } from 'zustand'
import { persist } from 'zustand/middleware'

interface AuthState {
  token: string | null
  userId: string | null
  setAuth: (token: string, userId: string) => void
  clearAuth: () => void
}

export const useAuthStore = create<AuthState>()(
  persist(
    (set) => ({
      token: null,
      userId: null,
      setAuth: (token, userId) => set({ token, userId }),
      clearAuth: () => set({ token: null, userId: null }),
    }),
    { name: 'ava-auth' }  // persisted to localStorage under key 'ava-auth'
  )
)
```

**frontend/src/api/auth.ts:**
```typescript
const BASE = ''  // Proxied by Vite dev server; in prod, same origin

export async function signIn(email: string, password: string) {
  const res = await fetch(`${BASE}/auth/signin`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ email, password }),
  })
  if (!res.ok) {
    const err = await res.json().catch(() => ({ detail: 'Sign in failed' }))
    throw new Error(err.detail ?? 'Sign in failed')
  }
  return res.json() as Promise<{ access_token: string; user_id: string }>
}

export async function signOut() {
  // JWT is stateless — clear locally, no server call needed
}
```

**frontend/src/api/chat.ts:**
```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'

export interface ChatMessage {
  id: string
  role: 'user' | 'assistant'
  content: string
  created_at: string
}

export function useChatHistory(token: string | null) {
  return useQuery({
    queryKey: ['chat-history'],
    queryFn: () =>
      fetch('/chat/history', {
        headers: { Authorization: `Bearer ${token}` },
      }).then(r => {
        if (!r.ok) throw new Error('Failed to load history')
        return r.json() as Promise<ChatMessage[]>
      }),
    enabled: !!token,
    refetchInterval: 3000,
  })
}

export function useSendMessage(token: string | null) {
  const queryClient = useQueryClient()
  return useMutation({
    mutationFn: (text: string) =>
      fetch('/chat', {
        method: 'POST',
        headers: {
          Authorization: `Bearer ${token}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ text }),
      }).then(r => {
        if (!r.ok) throw new Error('Failed to send message')
        return r.json() as Promise<{ reply: string }>
      }),
    onSuccess: () => queryClient.invalidateQueries({ queryKey: ['chat-history'] }),
  })
}
```

**frontend/src/api/preferences.ts:**
```typescript
export interface Preferences {
  whatsapp_phone?: string
  preferred_platform?: 'whatsapp' | 'web'
  spiciness_level?: 'mild' | 'spicy' | 'explicit'
  mode_switch_phrase?: string | null
  notif_prefs?: Record<string, unknown>
}

export async function getPreferences(token: string): Promise<Preferences> {
  const res = await fetch('/preferences/', {
    headers: { Authorization: `Bearer ${token}` },
  })
  if (res.status === 404) return {}
  if (!res.ok) throw new Error('Failed to load preferences')
  return res.json()
}

export async function updatePreferences(token: string, patch: Partial<Preferences>): Promise<void> {
  const res = await fetch('/preferences/', {
    method: 'PATCH',
    headers: {
      Authorization: `Bearer ${token}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(patch),
  })
  if (!res.ok) throw new Error('Failed to update preferences')
}
```

**frontend/src/pages/LoginPage.tsx:**
```tsx
import { useState } from 'react'
import { useNavigate } from 'react-router-dom'
import { signIn } from '../api/auth'
import { useAuthStore } from '../store/useAuthStore'

export default function LoginPage() {
  const [email, setEmail] = useState('')
  const [password, setPassword] = useState('')
  const [error, setError] = useState<string | null>(null)
  const [loading, setLoading] = useState(false)
  const setAuth = useAuthStore(s => s.setAuth)
  const navigate = useNavigate()

  async function handleSubmit(e: React.FormEvent) {
    e.preventDefault()
    setError(null)
    setLoading(true)
    try {
      const { access_token, user_id } = await signIn(email, password)
      setAuth(access_token, user_id)
      navigate('/chat')
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Sign in failed')
    } finally {
      setLoading(false)
    }
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50">
      <div className="bg-white rounded-2xl shadow-sm border border-gray-100 p-8 w-full max-w-sm">
        <h1 className="text-2xl font-semibold text-gray-900 mb-1">Welcome back</h1>
        <p className="text-gray-500 text-sm mb-6">Sign in to chat with Ava</p>
        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">Email</label>
            <input
              type="email"
              value={email}
              onChange={e => setEmail(e.target.value)}
              required
              className="w-full border border-gray-200 rounded-lg px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-gray-900"
              placeholder="you@example.com"
            />
          </div>
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">Password</label>
            <input
              type="password"
              value={password}
              onChange={e => setPassword(e.target.value)}
              required
              className="w-full border border-gray-200 rounded-lg px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-gray-900"
              placeholder="••••••••"
            />
          </div>
          {error && <p className="text-red-500 text-sm">{error}</p>}
          <button
            type="submit"
            disabled={loading}
            className="w-full bg-gray-900 text-white rounded-lg py-2 text-sm font-medium hover:bg-gray-700 disabled:opacity-50 transition-colors"
          >
            {loading ? 'Signing in...' : 'Sign in'}
          </button>
        </form>
      </div>
    </div>
  )
}
```

NOTE on signIn response shape: The existing `/auth/signin` endpoint in `backend/app/routers/auth.py` returns `{"access_token": ..., "token_type": "bearer"}`. It does NOT return `user_id` directly. After sign-in, fetch user_id from the JWT payload or call a `/auth/me` endpoint.

To handle this without modifying the backend in this plan: decode the JWT locally.
Update `frontend/src/api/auth.ts` signIn to extract user_id from the JWT payload:
```typescript
export async function signIn(email: string, password: string) {
  const res = await fetch('/auth/signin', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ email, password }),
  })
  if (!res.ok) {
    const err = await res.json().catch(() => ({ detail: 'Sign in failed' }))
    throw new Error(err.detail ?? 'Sign in failed')
  }
  const data = await res.json()
  // Decode JWT payload (base64url decode middle segment) to get sub (user_id)
  const payloadB64 = data.access_token.split('.')[1]
  const payload = JSON.parse(atob(payloadB64.replace(/-/g, '+').replace(/_/g, '/')))
  return { access_token: data.access_token, user_id: payload.sub as string }
}
```
  </action>
  <verify>
    <automated>cd /c/Users/raphg/Desktop/IA/ava2/frontend && npm run build 2>&1 | tail -10</automated>
    <manual>Confirm build completes with zero TypeScript errors. Check that LoginPage, auth store, and API modules are included in output.</manual>
  </verify>
  <done>
    useAuthStore.ts persists token to localStorage. auth.ts, chat.ts, preferences.ts exist with correct function signatures. LoginPage.tsx renders a styled form and calls signIn on submit. `npm run build` passes with no errors.
  </done>
</task>

</tasks>

<verification>
Run `cd frontend && npm run build` — must complete without TypeScript errors.
Confirm these files exist: frontend/src/store/useAuthStore.ts, frontend/src/api/auth.ts, frontend/src/api/chat.ts, frontend/src/api/preferences.ts, frontend/src/pages/LoginPage.tsx.
</verification>

<success_criteria>
- frontend/ directory exists with Vite + React + TypeScript + Tailwind v4 configured
- Vite dev server configured to proxy /auth, /chat, /preferences, /avatars, /photos to localhost:8000
- Zustand auth store persists token and user_id to localStorage under key 'ava-auth'
- API client modules exist with correct signatures for auth, chat, and preferences
- LoginPage renders email/password form and navigates to /chat on success
- App.tsx has protected route logic redirecting unauthenticated users to /login
- `npm run build` completes without errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-web-app-multi-platform/06-02-SUMMARY.md` summarizing:
- Frontend directory structure created
- Dependencies installed (include exact versions from package.json)
- Vite proxy configuration (which paths are proxied)
- JWT decode approach for user_id extraction
- Any deviations from the plan
</output>
