---
phase: 06-web-app-multi-platform
plan: 04
type: execute
wave: 2
depends_on:
  - "06-01"
  - "06-03"
files_modified:
  - backend/app/routers/web_chat.py
  - backend/app/routers/preferences.py
  - backend/app/routers/photo.py
  - backend/app/models/preferences.py
  - backend/app/config.py
  - backend/app/main.py
  - backend/app/services/chat.py
autonomous: true
requirements:
  - PLAT-02
  - PLAT-03
  - PLAT-04

must_haves:
  truths:
    - "POST /chat accepts text from web app, runs through WebAdapter + platform_router, returns {reply: str}"
    - "GET /chat/history returns recent web-channel messages filtered by channel='web'"
    - "GET/PATCH /preferences/ supports preferred_platform, spiciness_level, mode_switch_phrase, notif_prefs"
    - "POST /photos/signed-url returns a 24-hour Supabase Storage signed URL for a photo path"
    - "ChatService checks mode_switch_phrase (exact match, case-insensitive) BEFORE existing fuzzy detector"
    - "spiciness_level is passed to intimate_prompt() system prompt as a content ceiling instruction"
    - "web_chat router and photo router are registered in main.py"
  artifacts:
    - path: "backend/app/routers/web_chat.py"
      provides: "POST /chat and GET /chat/history endpoints"
      exports: ["router"]
    - path: "backend/app/routers/photo.py"
      provides: "POST /photos/signed-url — 24h Supabase Storage signed URL"
      exports: ["router"]
    - path: "backend/app/routers/preferences.py"
      provides: "Extended preferences router with PATCH /preferences/ and new fields"
      exports: ["router"]
    - path: "backend/app/services/chat.py"
      provides: "ChatService with mode_switch_phrase check and spiciness_level pass-through"
      min_lines: 250
  key_links:
    - from: "backend/app/routers/web_chat.py"
      to: "backend/app/adapters/web_adapter.py"
      via: "_web_adapter.receive()"
      pattern: "_web_adapter"
    - from: "backend/app/routers/web_chat.py"
      to: "public.messages"
      via: "supabase_admin insert channel='web'"
      pattern: "channel.*web"
    - from: "backend/app/routers/photo.py"
      to: "supabase_admin.storage"
      via: "create_signed_url(path, 86400)"
      pattern: "create_signed_url"
    - from: "backend/app/services/chat.py"
      to: "session.mode_switch_phrase"
      via: "exact match check before detect_mode_switch()"
      pattern: "mode_switch_phrase"
---

<objective>
Build the web chat API (POST /chat, GET /chat/history), extend the preferences API (PATCH with new Phase 6 fields), add the photo signed-URL endpoint, extend ChatService with mode_switch_phrase and spiciness_level support, and register all new routers in main.py.

Purpose: This gives the frontend chat page and settings page working API endpoints. ChatService gains two behavior extensions locked by user decisions: custom mode-switch phrase and spiciness ceiling.
Output: Three new/extended backend routers + ChatService extensions.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/06-web-app-multi-platform/06-RESEARCH.md
@backend/app/routers/preferences.py
@backend/app/services/chat.py
@backend/app/main.py
@backend/app/dependencies.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Web chat router, photo router, preferences extension, and main.py registration</name>
  <files>
    backend/app/routers/web_chat.py
    backend/app/routers/photo.py
    backend/app/routers/preferences.py
    backend/app/models/preferences.py
    backend/app/config.py
    backend/app/main.py
  </files>
  <action>
**backend/app/routers/web_chat.py — new file:**
```python
"""
Web chat router — POST /chat and GET /chat/history.

Uses WebAdapter → platform_router → ChatService pipeline.
Logs both turns to messages table with channel='web' (Pitfall 3: never mix with 'whatsapp').
"""
import logging
from datetime import datetime, timezone
from fastapi import APIRouter, Depends
from pydantic import BaseModel
from app.dependencies import get_current_user, get_authed_supabase
from app.adapters.base import NormalizedMessage
from app.adapters.web_adapter import WebAdapter
from app.services.session.store import get_session_store
from app.services.llm.openai_provider import OpenAIProvider
from app.services.chat import ChatService
from app.services.user_lookup import get_avatar_for_user
from app.database import supabase_admin
from app.config import settings

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/chat", tags=["chat"])

# Module-level singletons shared with webhook (same ChatService instance ensures shared session)
# Import from webhook to reuse — avoids creating a second ChatService with a different SessionStore
from app.routers.webhook import _chat_service

_web_adapter = WebAdapter(chat_service=_chat_service)


class ChatRequest(BaseModel):
    text: str


@router.post("")
async def send_message(
    body: ChatRequest,
    user=Depends(get_current_user),
):
    """
    Send a message via the web chat interface.
    Runs through WebAdapter → platform_router → ChatService.
    Returns {"reply": <Ava's response>}.
    """
    user_id = str(user.id)
    msg = NormalizedMessage(
        user_id=user_id,
        text=body.text,
        platform="web",
        timestamp=datetime.now(timezone.utc),
    )

    reply_text = await _web_adapter.receive(msg)

    # Log both turns to messages table with channel='web'
    # send() is a no-op for WebAdapter — reply returned in HTTP response
    avatar = await get_avatar_for_user(user_id)
    try:
        supabase_admin.from_("messages").insert([
            {
                "user_id": user_id,
                "avatar_id": avatar["id"] if avatar else None,
                "channel": "web",
                "role": "user",
                "content": body.text,
            },
            {
                "user_id": user_id,
                "avatar_id": avatar["id"] if avatar else None,
                "channel": "web",
                "role": "assistant",
                "content": reply_text,
            },
        ]).execute()
    except Exception as e:
        logger.error(f"Web message logging failed for user {user_id}: {e}")

    return {"reply": reply_text}


@router.get("/history")
async def get_chat_history(
    limit: int = 50,
    user=Depends(get_current_user),
    db=Depends(get_authed_supabase),
):
    """
    Return recent web-channel messages for the authenticated user.
    Filters to channel='web' only — never returns WhatsApp messages (Pitfall 3).
    Returns newest-first, limit defaults to 50.
    """
    result = (
        db.from_("messages")
        .select("id, role, content, created_at")
        .eq("channel", "web")
        .order("created_at", desc=True)
        .limit(min(limit, 200))
        .execute()
    )
    # Return in chronological order for display (reverse the newest-first fetch)
    messages = list(reversed(result.data or []))
    return messages
```

**backend/app/routers/photo.py — new file:**
```python
"""
Photo delivery router — POST /photos/signed-url.

Generates a 24-hour Supabase Storage signed URL for a photo stored in the private
'photos' bucket. The signed URL IS the auth token (per CONTEXT.md decision: no login
required to view, token = auth, 24h expiry).

Note: Photo GENERATION is Phase 7 (INTM-03). Phase 6 provides the delivery
infrastructure that Phase 7 will wire up.
"""
import logging
from fastapi import APIRouter, Depends, HTTPException
from pydantic import BaseModel
from app.dependencies import get_current_user
from app.database import supabase_admin

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/photos", tags=["photos"])

PHOTO_BUCKET = "photos"
SIGNED_URL_EXPIRY_SECONDS = 86400  # 24 hours


class SignedUrlRequest(BaseModel):
    photo_path: str  # e.g. "user-id/photo-filename.jpg"


@router.post("/signed-url")
async def create_photo_signed_url(
    body: SignedUrlRequest,
    user=Depends(get_current_user),
):
    """
    Generate a 24-hour signed URL for a photo in the private 'photos' Supabase Storage bucket.

    The signed URL is self-contained auth — no separate token table needed.
    Anyone with the link can view the photo for 24 hours.

    Called by Phase 7 image generation when a photo is ready for delivery.
    """
    try:
        response = (
            supabase_admin.storage
            .from_(PHOTO_BUCKET)
            .create_signed_url(body.photo_path, SIGNED_URL_EXPIRY_SECONDS)
        )
        signed_url = response.get("signedURL") or response.get("signed_url")
        if not signed_url:
            raise HTTPException(status_code=500, detail="Failed to generate signed URL")
        return {"signed_url": signed_url, "expires_in_seconds": SIGNED_URL_EXPIRY_SECONDS}
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Signed URL generation failed for path {body.photo_path}: {e}")
        raise HTTPException(status_code=500, detail="Photo URL generation failed")
```

**backend/app/models/preferences.py — extend:**
Read the current file first, then add new Pydantic models for the PATCH endpoint and the new fields.

Add after existing models:
```python
from pydantic import BaseModel
from typing import Optional, Literal, Any

class PreferencesPatchRequest(BaseModel):
    """Partial update of user preferences — all fields optional."""
    preferred_platform: Optional[Literal["whatsapp", "web"]] = None
    spiciness_level: Optional[Literal["mild", "spicy", "explicit"]] = None
    mode_switch_phrase: Optional[str] = None   # None = use system defaults
    notif_prefs: Optional[dict[str, Any]] = None
```

Also extend `PreferencesResponse` to include new fields (add Optional fields with defaults):
```python
class PreferencesResponse(BaseModel):
    whatsapp_phone: Optional[str] = None
    preferred_platform: Optional[str] = "whatsapp"
    spiciness_level: Optional[str] = "mild"
    mode_switch_phrase: Optional[str] = None
    notif_prefs: Optional[dict] = None
```

Read the actual current PreferencesResponse first and extend it without breaking existing fields.

**backend/app/routers/preferences.py — extend:**
Add PATCH /preferences/ endpoint to the existing router:
```python
from app.models.preferences import PhoneLinkRequest, PreferencesResponse, PreferencesPatchRequest

@router.patch("/", response_model=PreferencesResponse)
async def update_preferences(
    body: PreferencesPatchRequest,
    user=Depends(get_current_user),
    db=Depends(get_authed_supabase),
):
    """
    Update user preferences. Only provided fields are updated (PATCH semantics).
    Returns the full updated preferences row.
    """
    patch = body.model_dump(exclude_none=True)
    if not patch:
        raise HTTPException(status_code=400, detail="No fields to update")

    db.from_("user_preferences").upsert({
        "user_id": str(user.id),
        **patch,
    }).execute()

    result = db.from_("user_preferences").select("*").eq("user_id", str(user.id)).execute()
    if not result.data:
        raise HTTPException(status_code=404, detail="Preferences not found after update")
    return result.data[0]
```

**backend/app/config.py — add frontend_url:**
Add `frontend_url: str = "http://localhost:3000"` to the Settings class (used in CORS configuration).

**backend/app/main.py — register new routers and update CORS:**
```python
# Add imports for new routers
from app.routers import web_chat, photo

# Add to router registrations (after existing routers):
app.include_router(web_chat.router)
app.include_router(photo.router)

# Update CORS to use settings.frontend_url for production:
app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        "http://localhost:3000",
        "http://localhost:8000",
        "http://127.0.0.1:8000",
        "http://127.0.0.1:3000",
        settings.frontend_url,  # Add production URL from env
    ],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
```

Import `settings` at top of main.py if not already imported.
  </action>
  <verify>
    <automated>cd /c/Users/raphg/Desktop/IA/ava2/backend && python -c "
import app.routers.web_chat as wc
import app.routers.photo as ph
import app.routers.preferences as pr
# Check routes exist
routes = {r.path for r in wc.router.routes}
print('web_chat routes:', routes)
assert '/chat' in routes or any('/chat' in str(r.path) for r in wc.router.routes)
photo_routes = {r.path for r in ph.router.routes}
print('photo routes:', photo_routes)
pref_routes = [r.path for r in pr.router.routes]
print('pref routes:', pref_routes)
print('All routers loaded OK')
"
    </automated>
  </verify>
  <done>
    web_chat.py has POST /chat and GET /chat/history routes. photo.py has POST /photos/signed-url route. preferences.py has PATCH /preferences/ route. Both new routers are registered in main.py. CORS includes settings.frontend_url.
  </done>
</task>

<task type="auto">
  <name>Task 2: ChatService — mode_switch_phrase and spiciness_level extensions</name>
  <files>
    backend/app/services/chat.py
  </files>
  <action>
Extend ChatService.handle_message() with two behavior changes locked by user decisions:

**Change 1: mode_switch_phrase check (CONTEXT.md: "mode-switch phrase — user-configurable phrase")**

Add a check BEFORE the existing `detect_mode_switch()` call. Per RESEARCH.md Pitfall 8 and recommendation:
- Exact match (case-insensitive, stripped)
- Custom phrase takes priority over fuzzy detection
- Only triggers if mode_switch_phrase is set in user preferences

Implementation: Load mode_switch_phrase from user preferences in handle_message() using supabase_admin, then check it.

Insert this logic right before `# --- Mode switch detection ---`:
```python
# --- Custom mode-switch phrase check (runs BEFORE fuzzy detection) ---
# Per CONTEXT.md: user-configurable phrase stored in user_preferences.
# Exact match, case-insensitive, stripped. Priority over fuzzy detector.
try:
    prefs_result = supabase_admin.from_("user_preferences") \
        .select("mode_switch_phrase, spiciness_level") \
        .eq("user_id", user_id) \
        .maybe_single() \
        .execute()
    prefs = prefs_result.data or {}
except Exception as e:
    logger.warning(f"Preferences fetch failed for user {user_id}: {e}")
    prefs = {}

custom_phrase = prefs.get("mode_switch_phrase")
if custom_phrase and incoming_text.strip().lower() == custom_phrase.strip().lower():
    # Phrase matches — toggle mode (intimate → secretary, secretary → intimate)
    target = (
        ConversationMode.INTIMATE
        if session.mode == ConversationMode.SECRETARY
        else ConversationMode.SECRETARY
    )
    await self._store.switch_mode(user_id, target)
    if target == ConversationMode.INTIMATE:
        return SWITCH_TO_INTIMATE_MSG
    else:
        return SWITCH_TO_SECRETARY_MSG

spiciness_level = prefs.get("spiciness_level", "mild")
```

**Change 2: spiciness_level passed to intimate_prompt() (CONTEXT.md: "Spiciness ceiling — Ava will not escalate beyond the user's chosen level")**

Extend the existing `intimate_prompt()` call to pass spiciness_level:

Current code in chat.py:
```python
else:
    system_prompt = intimate_prompt(avatar_name, personality)
```

Change to:
```python
else:
    system_prompt = intimate_prompt(avatar_name, personality, spiciness_level)
```

Also update `backend/app/services/llm/prompts.py` to accept `spiciness_level` in `intimate_prompt()`:
- Add `spiciness_level: str = "mild"` parameter
- Append ceiling instruction to the prompt based on level:
  - "mild": "Keep responses flirty and suggestive but tasteful — no explicit content."
  - "spicy": "You may be suggestive and sensual — avoid graphic explicit content."
  - "explicit": "You may be fully explicit and adult in your responses within legal and safety constraints."

Read `backend/app/services/llm/prompts.py` first to understand the current intimate_prompt() signature before modifying it.

**Important notes:**
- The `prefs` dict (mode_switch_phrase + spiciness_level) is fetched once per message and reused for both checks. This single DB call is acceptable overhead for behavior correctness.
- The spiciness_level variable is initialized to "mild" default before the gate checks so it is always defined when reached by the LLM call path.
- Import `supabase_admin` at the top of chat.py if not already imported (use deferred import inside the handler like the existing guardrail helpers, or add it to module-level imports — either is acceptable).
  </action>
  <verify>
    <automated>cd /c/Users/raphg/Desktop/IA/ava2/backend && python -c "
from app.services.chat import ChatService
from app.services.llm.prompts import intimate_prompt
import inspect
sig = inspect.signature(intimate_prompt)
print('intimate_prompt params:', list(sig.parameters.keys()))
assert 'spiciness_level' in sig.parameters, 'spiciness_level param missing from intimate_prompt'
# Check chat.py has mode_switch_phrase
import inspect as ins
src = ins.getsource(ChatService.handle_message)
assert 'mode_switch_phrase' in src, 'mode_switch_phrase check missing from handle_message'
assert 'spiciness_level' in src, 'spiciness_level missing from handle_message'
print('ChatService extensions verified')
"
    </automated>
    <automated>cd /c/Users/raphg/Desktop/IA/ava2/backend && python -m pytest tests/ -x -q 2>&1 | tail -10</automated>
  </verify>
  <done>
    intimate_prompt() accepts spiciness_level parameter and includes ceiling instruction in system prompt. ChatService.handle_message() checks mode_switch_phrase before detect_mode_switch(). All existing pytest tests continue to pass.
  </done>
</task>

</tasks>

<verification>
Run: `cd backend && python -m pytest tests/ -x -q` — all tests pass.
Run: `cd backend && python -c "from app.main import app; print([r.path for r in app.routes])"` — confirm /chat and /photos/signed-url appear in routes.
</verification>

<success_criteria>
- POST /chat endpoint processes web messages through WebAdapter → platform_router → ChatService
- GET /chat/history filters to channel='web' only
- PATCH /preferences/ accepts preferred_platform, spiciness_level, mode_switch_phrase, notif_prefs
- POST /photos/signed-url returns 24h signed URL from Supabase Storage
- ChatService checks user's mode_switch_phrase (exact match) BEFORE fuzzy detection
- intimate_prompt() includes spiciness ceiling instruction based on user's level
- All existing tests pass
- main.py registers web_chat and photo routers
</success_criteria>

<output>
After completion, create `.planning/phases/06-web-app-multi-platform/06-04-SUMMARY.md` summarizing:
- New endpoints added and their routes
- ChatService changes (mode_switch_phrase priority, spiciness_level flow)
- intimate_prompt() signature change
- Any deviations or gotchas
</output>
