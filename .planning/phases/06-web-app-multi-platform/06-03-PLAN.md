---
phase: 06-web-app-multi-platform
plan: 03
type: execute
wave: 2
depends_on:
  - "06-01"
files_modified:
  - backend/app/adapters/__init__.py
  - backend/app/adapters/base.py
  - backend/app/adapters/whatsapp_adapter.py
  - backend/app/adapters/web_adapter.py
  - backend/app/services/platform_router.py
  - backend/app/routers/webhook.py
autonomous: true
requirements:
  - PLAT-05
  - PLAT-04

must_haves:
  truths:
    - "PlatformAdapter Protocol with receive() and send() exists in adapters/base.py"
    - "NormalizedMessage dataclass carries user_id, text, platform, timestamp"
    - "WhatsAppAdapter wraps existing webhook.py logic and satisfies the Protocol"
    - "WebAdapter satisfies the Protocol for HTTP-originated messages"
    - "platform_router.py checks preferred_platform, returns in-character redirect when mismatch, dispatches to ChatService when match"
    - "webhook.py refactored to use WhatsAppAdapter and platform_router"
  artifacts:
    - path: "backend/app/adapters/base.py"
      provides: "PlatformAdapter Protocol + NormalizedMessage dataclass"
      exports: ["PlatformAdapter", "NormalizedMessage"]
    - path: "backend/app/adapters/whatsapp_adapter.py"
      provides: "WhatsAppAdapter concrete class satisfying PlatformAdapter"
      exports: ["WhatsAppAdapter"]
    - path: "backend/app/services/platform_router.py"
      provides: "platform_router.route() â€” preferred_platform check + ChatService dispatch"
      exports: ["route"]
    - path: "backend/app/routers/webhook.py"
      provides: "Refactored webhook using WhatsAppAdapter"
      min_lines: 60
  key_links:
    - from: "backend/app/adapters/whatsapp_adapter.py"
      to: "backend/app/services/platform_router.py"
      via: "route() call in receive()"
      pattern: "await route"
    - from: "backend/app/routers/webhook.py"
      to: "backend/app/adapters/whatsapp_adapter.py"
      via: "_whatsapp_adapter singleton"
      pattern: "WhatsAppAdapter"
    - from: "backend/app/services/platform_router.py"
      to: "public.user_preferences"
      via: "supabase_admin preferred_platform lookup"
      pattern: "preferred_platform"
---

<objective>
Build the platform adapter abstraction layer (PLAT-05): PlatformAdapter Protocol, NormalizedMessage, WhatsAppAdapter, WebAdapter stubs, and platform_router.py. Refactor webhook.py to use the new adapter pattern.

Purpose: This is the architectural core of Phase 6. All messaging â€” whether from WhatsApp or the web app â€” flows through the same platform_router.py â†’ ChatService pipeline. New platforms require only a new adapter class.
Output: backend/app/adapters/ package + backend/app/services/platform_router.py + refactored webhook.py.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/06-web-app-multi-platform/06-RESEARCH.md

Existing code to understand and refactor:
@backend/app/routers/webhook.py
@backend/app/services/chat.py
@backend/app/services/llm/base.py
@backend/app/services/user_lookup.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: PlatformAdapter Protocol, NormalizedMessage, and platform_router</name>
  <files>
    backend/app/adapters/__init__.py
    backend/app/adapters/base.py
    backend/app/services/platform_router.py
  </files>
  <action>
**backend/app/adapters/__init__.py:**
Empty init file (creates the package).

**backend/app/adapters/base.py:**
Mirror the LLMProvider pattern from `backend/app/services/llm/base.py` â€” Python Protocol, runtime_checkable, no inheritance required.

```python
"""
Platform adapter abstraction layer (PLAT-05).

Any class with async receive() and send() satisfies PlatformAdapter Protocol â€”
no inheritance required. To add a new platform: implement a class with this
signature. No changes to core ChatService or business logic needed.

Mirrors LLMProvider Protocol pattern from Phase 3 (app/services/llm/base.py).
"""
from typing import Protocol, runtime_checkable
from dataclasses import dataclass
from datetime import datetime


@dataclass
class NormalizedMessage:
    """
    Minimal message envelope shared across all platform adapters.

    All platform-specific metadata (WhatsApp message ID, web session ID, etc.)
    is stripped. Core pipeline only sees user_id, text, platform, and timestamp.
    """
    user_id: str
    text: str
    platform: str        # "whatsapp" | "web"
    timestamp: datetime


@runtime_checkable
class PlatformAdapter(Protocol):
    """
    Structural interface for platform adapters.

    receive(): Feed a normalized inbound message into the core pipeline. Returns reply text.
    send(): Deliver reply text to the user on this platform.

    Adapters handle transport only â€” no business logic, no mode detection,
    no content guardrails. All of that lives in ChatService via platform_router.
    """

    async def receive(self, message: NormalizedMessage) -> str:
        """Process inbound message through platform_router â†’ ChatService. Returns reply."""
        ...

    async def send(self, user_id: str, text: str) -> None:
        """Deliver reply to the user on this platform."""
        ...
```

**backend/app/services/platform_router.py:**
```python
"""
Platform router â€” checks user's preferred_platform before dispatching to ChatService.

Called by both WhatsAppAdapter and WebAdapter. Keeps preferred_platform enforcement
in one place (not duplicated across adapters â€” per research anti-patterns section).

Decision: preferred_platform lookup uses supabase_admin (service role) because
WhatsApp adapter runs in webhook context without a user JWT (Pitfall 5 in RESEARCH.md).
"""
import logging
from app.database import supabase_admin
from app.adapters.base import NormalizedMessage
from app.services.chat import ChatService

logger = logging.getLogger(__name__)

# In-character warm redirect message (per CONTEXT.md decisions)
_REDIRECT_TEMPLATE = (
    "Hey ðŸ˜Š I mostly hang out on {preferred} â€” come find me there! "
    "(You can change this in settings)"
)
_PLATFORM_LABELS = {
    "whatsapp": "WhatsApp",
    "web": "the web app",
}


async def route(
    chat_service: ChatService,
    user_id: str,
    incoming_platform: str,
    message: NormalizedMessage,
    avatar: dict | None,
) -> str:
    """
    Check preferred_platform. If mismatch, return in-character redirect.
    If match (or no preference set), dispatch to ChatService.handle_message().

    Args:
        chat_service: Module-level ChatService singleton.
        user_id: Authenticated user UUID.
        incoming_platform: Platform this message arrived on ("whatsapp" or "web").
        message: Normalized message envelope.
        avatar: Avatar row from DB (name, personality) or None if not set up.

    Returns:
        Reply text to deliver back via the adapter's send().
    """
    try:
        result = (
            supabase_admin
            .from_("user_preferences")
            .select("preferred_platform")
            .eq("user_id", user_id)
            .maybe_single()
            .execute()
        )
        preferred = (result.data or {}).get("preferred_platform")
    except Exception as e:
        logger.error(f"preferred_platform lookup failed for user {user_id}: {e}")
        preferred = None  # Default: allow message through

    # If user has a preference AND the incoming platform doesn't match â†’ redirect
    if preferred and preferred != incoming_platform:
        label = _PLATFORM_LABELS.get(preferred, preferred)
        return _REDIRECT_TEMPLATE.format(preferred=label)

    # No preference set, or preference matches â†’ dispatch to core pipeline
    return await chat_service.handle_message(
        user_id=user_id,
        incoming_text=message.text,
        avatar=avatar,
    )
```
  </action>
  <verify>
    <automated>cd /c/Users/raphg/Desktop/IA/ava2/backend && python -c "
from app.adapters.base import PlatformAdapter, NormalizedMessage
from app.services.platform_router import route
print('PlatformAdapter:', PlatformAdapter)
print('NormalizedMessage fields:', NormalizedMessage.__dataclass_fields__.keys())
print('route:', route)
print('All imports OK')
"
    </automated>
  </verify>
  <done>
    backend/app/adapters/base.py defines PlatformAdapter Protocol and NormalizedMessage dataclass. platform_router.py imports correctly, uses supabase_admin for preferred_platform lookup, and returns redirect or dispatches to ChatService.
  </done>
</task>

<task type="auto">
  <name>Task 2: WhatsApp and Web adapters, webhook.py refactor</name>
  <files>
    backend/app/adapters/whatsapp_adapter.py
    backend/app/adapters/web_adapter.py
    backend/app/routers/webhook.py
  </files>
  <action>
**backend/app/adapters/whatsapp_adapter.py:**
```python
"""
WhatsApp platform adapter â€” satisfies PlatformAdapter Protocol without inheritance.

Wraps existing webhook send/receive logic extracted from webhook.py.
receive() â†’ platform_router â†’ ChatService
send() â†’ send_whatsapp_message() via Meta Graph API
"""
import logging
from datetime import datetime, timezone
from app.adapters.base import NormalizedMessage
from app.services.user_lookup import get_avatar_for_user
from app.services.whatsapp import send_whatsapp_message
from app.services.platform_router import route
from app.database import supabase_admin

logger = logging.getLogger(__name__)


class WhatsAppAdapter:
    """
    Concrete WhatsApp adapter. Satisfies PlatformAdapter Protocol â€” no imports
    of PlatformAdapter needed in this file. The Protocol check is structural.
    """

    def __init__(self, chat_service, phone_number_id: str):
        self._chat_service = chat_service
        self._phone_number_id = phone_number_id

    async def receive(self, message: NormalizedMessage) -> str:
        """Route inbound WhatsApp message through platform_router â†’ ChatService."""
        avatar = await get_avatar_for_user(message.user_id)
        return await route(
            chat_service=self._chat_service,
            user_id=message.user_id,
            incoming_platform="whatsapp",
            message=message,
            avatar=avatar,
        )

    async def send(self, user_id: str, text: str) -> None:
        """Deliver reply to WhatsApp by resolving user_id â†’ phone â†’ Meta API."""
        try:
            result = (
                supabase_admin
                .from_("user_preferences")
                .select("whatsapp_phone")
                .eq("user_id", user_id)
                .maybe_single()
                .execute()
            )
            phone = (result.data or {}).get("whatsapp_phone")
            if not phone:
                logger.warning(f"No WhatsApp phone for user {user_id} â€” cannot deliver reply")
                return
            await send_whatsapp_message(
                phone_number_id=self._phone_number_id,
                to=phone,
                text=text,
            )
        except Exception as e:
            logger.error(f"WhatsApp send failed for user {user_id}: {e}")
```

**backend/app/adapters/web_adapter.py:**
```python
"""
Web platform adapter â€” satisfies PlatformAdapter Protocol for HTTP-originated messages.

receive() is called directly by the web_chat.py router (POST /chat).
send() is a no-op for the web adapter: the reply is returned synchronously via
the HTTP response â€” there is no async push needed.
"""
import logging
from app.adapters.base import NormalizedMessage
from app.services.user_lookup import get_avatar_for_user
from app.services.platform_router import route

logger = logging.getLogger(__name__)


class WebAdapter:
    """
    Concrete Web adapter. HTTP request â†’ ChatService â†’ HTTP response.
    send() is intentionally a no-op: web replies are returned in the HTTP response body.
    """

    def __init__(self, chat_service):
        self._chat_service = chat_service

    async def receive(self, message: NormalizedMessage) -> str:
        """Route inbound web message through platform_router â†’ ChatService."""
        avatar = await get_avatar_for_user(message.user_id)
        return await route(
            chat_service=self._chat_service,
            user_id=message.user_id,
            incoming_platform="web",
            message=message,
            avatar=avatar,
        )

    async def send(self, user_id: str, text: str) -> None:
        """No-op: web replies are returned synchronously in the HTTP response."""
        pass
```

**backend/app/routers/webhook.py â€” refactor:**
Refactor to use WhatsAppAdapter instead of calling ChatService directly. Preserve all existing behavior (200 on error, message logging, unlinked-number handling). The key change is: extract `process_whatsapp_message` logic into the adapter's `receive()` + `send()` calls.

```python
from fastapi import APIRouter, Request, HTTPException, Query
from datetime import datetime, timezone
from app.config import settings
from app.services.user_lookup import lookup_user_by_phone
from app.services.session.store import get_session_store
from app.services.llm.openai_provider import OpenAIProvider
from app.services.chat import ChatService
from app.adapters.whatsapp_adapter import WhatsAppAdapter
from app.database import supabase_admin
import logging

router = APIRouter(prefix="/webhook", tags=["webhook"])
logger = logging.getLogger(__name__)

# Module-level singletons â€” instantiated once at import time
_llm_provider = OpenAIProvider(
    api_key=settings.openai_api_key,
    model=settings.llm_model,
)
_chat_service = ChatService(llm=_llm_provider, session_store=get_session_store())
_whatsapp_adapter = WhatsAppAdapter(
    chat_service=_chat_service,
    phone_number_id=settings.whatsapp_phone_number_id,
)


@router.get("")
async def verify_webhook(
    hub_mode: str = Query(None, alias="hub.mode"),
    hub_challenge: str = Query(None, alias="hub.challenge"),
    hub_verify_token: str = Query(None, alias="hub.verify_token"),
):
    if hub_mode == "subscribe" and hub_verify_token == settings.whatsapp_verify_token:
        return int(hub_challenge)
    raise HTTPException(status_code=403, detail="Forbidden")


@router.post("")
async def handle_incoming(request: Request):
    """
    Meta delivers incoming WhatsApp messages here.
    Always returns HTTP 200 â€” non-200 causes Meta to retry (duplicate messages).
    """
    try:
        body = await request.json()
        await process_whatsapp_message(body)
    except Exception as e:
        logger.error(f"Webhook processing error: {e}")
    return {"status": "ok"}


async def process_whatsapp_message(body: dict) -> None:
    """Process incoming WhatsApp webhook payload via WhatsAppAdapter pipeline."""
    from app.adapters.base import NormalizedMessage

    value = body["entry"][0]["changes"][0]["value"]
    if "messages" not in value:
        return  # Delivery receipt or status update â€” ignore

    message = value["messages"][0]
    sender_phone = message["from"]
    message_type = message.get("type")

    if message_type != "text":
        return  # Text only in Phase 6

    incoming_text = message["text"]["body"]

    # Look up user by phone (service role â€” no user JWT in webhook context)
    user = await lookup_user_by_phone(sender_phone)

    if user is None:
        # Unlinked number â€” send registration instructions via direct API call
        from app.services.whatsapp import send_whatsapp_message
        phone_number_id = value["metadata"]["phone_number_id"]
        await send_whatsapp_message(
            phone_number_id=phone_number_id,
            to=sender_phone,
            text="Please create an account at ava.example.com and link your number",
        )
        return

    user_id = user["user_id"]

    msg = NormalizedMessage(
        user_id=user_id,
        text=incoming_text,
        platform="whatsapp",
        timestamp=datetime.now(timezone.utc),
    )

    # receive() â†’ platform_router â†’ ChatService â†’ returns reply text
    reply_text = await _whatsapp_adapter.receive(msg)

    # Send reply (adapter resolves user_id â†’ phone internally)
    await _whatsapp_adapter.send(user_id, reply_text)

    # Log both messages to Supabase (DB failure must not prevent reply â€” already sent)
    from app.services.user_lookup import get_avatar_for_user
    avatar = await get_avatar_for_user(user_id)
    try:
        supabase_admin.from_("messages").insert([
            {
                "user_id": user_id,
                "avatar_id": avatar["id"] if avatar else None,
                "channel": "whatsapp",
                "role": "user",
                "content": incoming_text,
            },
            {
                "user_id": user_id,
                "avatar_id": avatar["id"] if avatar else None,
                "channel": "whatsapp",
                "role": "assistant",
                "content": reply_text,
            },
        ]).execute()
    except Exception as e:
        logger.error(f"Message logging failed for user {user_id}: {e}")
```

NOTE: The `_whatsapp_adapter.send()` now resolves user_id â†’ phone internally (instead of webhook.py having the phone). This is correct because platform_router.route() already looked up the user by user_id â€” the adapter has user_id, not the phone number directly at this point.
  </action>
  <verify>
    <automated>cd /c/Users/raphg/Desktop/IA/ava2/backend && python -c "
from app.adapters.whatsapp_adapter import WhatsAppAdapter
from app.adapters.web_adapter import WebAdapter
from app.adapters.base import PlatformAdapter
# Structural check: both adapters satisfy the Protocol
wa = WhatsAppAdapter.__new__(WhatsAppAdapter)
web = WebAdapter.__new__(WebAdapter)
print('WhatsAppAdapter is PlatformAdapter:', isinstance(wa, PlatformAdapter))
print('WebAdapter is PlatformAdapter:', isinstance(web, PlatformAdapter))
# Import webhook to check it loads
import app.routers.webhook as wh
print('webhook singletons:', '_whatsapp_adapter' in dir(wh))
print('All checks passed')
"
    </automated>
  </verify>
  <done>
    WhatsAppAdapter and WebAdapter exist, both satisfy PlatformAdapter Protocol. webhook.py imports WhatsAppAdapter and uses it for receive/send. platform_router.route() is the single point of preferred_platform enforcement. Both isinstance() checks pass at runtime.
  </done>
</task>

</tasks>

<verification>
Run the automated verify command for both tasks from backend/ directory.
Confirm: `python -m pytest backend/tests/ -x -q` still passes (existing tests must not break).
</verification>

<success_criteria>
- backend/app/adapters/ package exists with __init__.py, base.py, whatsapp_adapter.py, web_adapter.py
- PlatformAdapter Protocol is runtime_checkable; both adapters pass isinstance() check
- platform_router.py uses supabase_admin for preferred_platform lookup (not user JWT)
- platform_router.py returns in-character redirect when preferred_platform != incoming_platform
- webhook.py uses _whatsapp_adapter singleton instead of calling ChatService directly
- All existing pytest tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/06-web-app-multi-platform/06-03-SUMMARY.md` summarizing:
- Files created and their responsibilities
- How the Protocol structural check works (runtime_checkable + isinstance)
- The platform_router.route() function signature
- Any deviations from the plan or gotchas encountered
</output>
