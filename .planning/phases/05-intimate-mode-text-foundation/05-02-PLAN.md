---
phase: 05-intimate-mode-text-foundation
plan: "02"
type: execute
wave: 2
depends_on:
  - "05-01"
files_modified:
  - backend/app/services/chat.py
autonomous: true
requirements:
  - INTM-01
  - INTM-02

must_haves:
  truths:
    - "A message containing 'kill myself' returns the 988 crisis response, not an LLM reply"
    - "A message containing 'child roleplay' in intimate mode returns a hard refusal, not an LLM reply"
    - "A clean intimate-mode message produces an LLM reply (guards do not block it)"
    - "A message containing 'kill myself' in secretary mode also returns the crisis response (crisis runs all modes)"
    - "Guardrail triggers are logged to audit_log via supabase_admin (try/except so DB failure cannot block delivery)"
    - "Crisis detections are logged to audit_log with event_type='crisis_detected' (separate from guardrail events)"
    - "ContentGuard does NOT run in secretary mode"
  artifacts:
    - path: "backend/app/services/chat.py"
      provides: "ChatService.handle_message() with crisis gate (all modes) and content guard gate (intimate only)"
      contains: "crisis_detector.check_message"
    - path: "backend/app/services/chat.py"
      provides: "_log_guardrail_trigger() and _log_crisis() async helpers with try/except"
      contains: "_log_guardrail_trigger"
  key_links:
    - from: "backend/app/services/chat.py"
      to: "backend/app/services/crisis/detector.py"
      via: "crisis_detector.check_message(incoming_text, history)"
      pattern: "crisis_detector\\.check_message"
    - from: "backend/app/services/chat.py"
      to: "backend/app/services/content_guard/guard.py"
      via: "content_guard.check_message(incoming_text) inside INTIMATE mode branch"
      pattern: "content_guard\\.check_message"
    - from: "backend/app/services/chat.py"
      to: "supabase_admin"
      via: "_log_guardrail_trigger() and _log_crisis() write to audit_log"
      pattern: "audit_log.*insert|insert.*audit_log"
---

<objective>
Wire ContentGuard and CrisisDetector into ChatService as pre-LLM early-return gates, with audit logging for both.

Purpose: This is the final integration step that makes intimate mode safe and compliant. Guards slot into the existing handle_message() flow as early returns — no structural changes to the rest of the method.

Output: Modified chat.py with crisis gate (all modes) and content guard gate (intimate only), plus two audit logging helpers.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-intimate-mode-text-foundation/05-CONTEXT.md
@.planning/phases/05-intimate-mode-text-foundation/05-RESEARCH.md
@backend/app/services/chat.py
@.planning/phases/05-intimate-mode-text-foundation/05-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Audit Logging Helpers to ChatService</name>
  <files>backend/app/services/chat.py</files>
  <action>
Add two async helper functions to `chat.py` for audit logging. These are module-level functions (not methods), placed after the constants and before the `ChatService` class definition.

**`_log_guardrail_trigger(user_id: str, category: str | None) -> None`:**
```python
async def _log_guardrail_trigger(user_id: str, category: str | None) -> None:
    """Log content guardrail trigger to audit_log. Non-fatal — DB failure is logged, not raised."""
    try:
        from app.database import supabase_admin
        supabase_admin.from_("audit_log").insert({
            "user_id": user_id,
            "event_type": "content_guardrail_triggered",
            "event_category": "moderation",
            "action": "block",
            "resource_type": "message",
            "event_data": {"category": category},
            "result": "blocked",
        }).execute()
    except Exception as e:
        logger.error(f"Guardrail audit log write failed for user {user_id}: {e}")
```

**`_log_crisis(user_id: str, triggering_phrases: list[str]) -> None`:**
```python
async def _log_crisis(user_id: str, triggering_phrases: list[str]) -> None:
    """Log crisis detection to audit_log (separate event_type from guardrail). Non-fatal."""
    try:
        from app.database import supabase_admin
        supabase_admin.from_("audit_log").insert({
            "user_id": user_id,
            "event_type": "crisis_detected",
            "event_category": "moderation",
            "action": "pivot",
            "resource_type": "message",
            "event_data": {"triggering_phrases": triggering_phrases},
            "result": "crisis_response_sent",
        }).execute()
    except Exception as e:
        logger.error(f"Crisis audit log write failed for user {user_id}: {e}")
```

Per RESEARCH.md Pattern 6: use `supabase_admin` (service role) — webhook pipeline runs without user JWT. Per RESEARCH.md Pitfall 4: wrap in try/except — DB failure cannot block message delivery.

Per CONTEXT.md locked decision: crisis and guardrail are logged separately (different `event_type` values) so they can be queried independently for compliance reporting.

Also add the imports at the top of chat.py:
```python
from app.services.content_guard.guard import content_guard, _REFUSAL_MESSAGES
from app.services.crisis.detector import crisis_detector, CRISIS_RESPONSE
```
  </action>
  <verify>
    <automated>cd C:/Users/raphg/Desktop/IA/ava2 && python -c "
import ast, sys
with open('backend/app/services/chat.py') as f:
    src = f.read()
assert '_log_guardrail_trigger' in src, 'missing _log_guardrail_trigger'
assert '_log_crisis' in src, 'missing _log_crisis'
assert 'content_guard' in src and '_REFUSAL_MESSAGES' in src, 'missing content_guard import'
assert 'crisis_detector' in src and 'CRISIS_RESPONSE' in src, 'missing crisis_detector import'
# Verify it parses
ast.parse(src)
print('OK: chat.py has audit helpers and imports')
"</automated>
  </verify>
  <done>_log_guardrail_trigger and _log_crisis are defined with try/except; content_guard and crisis_detector imported at top of chat.py; file parses without errors.</done>
</task>

<task type="auto">
  <name>Task 2: Wire Guard Gates into handle_message()</name>
  <files>backend/app/services/chat.py</files>
  <action>
Insert the two pre-LLM gates into `ChatService.handle_message()`. Read the existing method carefully before editing.

**Gate placement** (per RESEARCH.md Pattern 4 and anti-patterns):

Insert AFTER the existing "snapshot history" line:
```python
history = list(session.history[current_mode])  # snapshot before append
```

And BEFORE the existing secretary skill dispatch block:
```python
if current_mode == ConversationMode.SECRETARY:
    try:
        intent = await classify_intent(...)
```

**GATE 1 — Crisis detection (ALL modes):**
```python
# --- GATE 1: Crisis detection — runs in all modes ---
crisis = crisis_detector.check_message(incoming_text, history)
if crisis.detected:
    await _log_crisis(user_id, crisis.triggering_phrases)
    user_message_crisis: Message = {"role": "user", "content": incoming_text}
    await self._store.append_message(user_id, current_mode, user_message_crisis)
    await self._store.append_message(
        user_id, current_mode, {"role": "assistant", "content": CRISIS_RESPONSE}
    )
    return CRISIS_RESPONSE
```

**GATE 2 — Content guardrail (INTIMATE mode only):**
```python
# --- GATE 2: Content guardrail — intimate mode only ---
if current_mode == ConversationMode.INTIMATE:
    guard = content_guard.check_message(incoming_text)
    if guard.blocked:
        await _log_guardrail_trigger(user_id, guard.category)
        refusal = _REFUSAL_MESSAGES.get(guard.category or "default", _REFUSAL_MESSAGES["default"])
        user_message_guard: Message = {"role": "user", "content": incoming_text}
        await self._store.append_message(user_id, current_mode, user_message_guard)
        await self._store.append_message(
            user_id, current_mode, {"role": "assistant", "content": refusal}
        )
        return refusal
```

**Critical ordering rules (from RESEARCH.md):**
1. Crisis gate runs FIRST, in all modes
2. Content guard gate runs SECOND, intimate mode only
3. Secretary skill dispatch runs THIRD (unchanged)
4. LLM call is the final fallback (unchanged)

**Do NOT change:**
- The pending clarification gate (pending_switch_to) — it stays before mode detection
- The calendar conflict gate — stays before mode detection
- The mode switch detection block — stays where it is
- The secretary skill dispatch try/except — stays where it is
- The final LLM call — stays where it is

**history variable:** The history snapshot is already taken before this insertion point (`history = list(session.history[current_mode])`). Pass this `history` to `crisis_detector.check_message(incoming_text, history)` — this gives CrisisDetector the recent context needed for Layer 2 scoring.

**Pitfall 6 check (from RESEARCH.md):** Verify content_guard is only called inside `if current_mode == ConversationMode.INTIMATE:`. Secretary-mode messages about "minor software bugs" must never trigger the guardrail.
  </action>
  <verify>
    <automated>cd C:/Users/raphg/Desktop/IA/ava2 && python -c "
import ast
with open('backend/app/services/chat.py') as f:
    src = f.read()
ast.parse(src)
# Verify ordering: crisis gate appears before content guard
crisis_pos = src.index('crisis_detector.check_message')
guard_pos = src.index('content_guard.check_message')
assert crisis_pos < guard_pos, 'crisis gate must appear before content guard'
# Verify content guard is inside intimate mode branch
guard_block = src[src.index('content_guard.check_message')-200:src.index('content_guard.check_message')+50]
assert 'INTIMATE' in guard_block, 'content_guard must be inside intimate mode branch'
print('OK: gate ordering and mode guard correct')
"</automated>
    <manual>Read handle_message() in chat.py. Confirm: (1) crisis gate is before content guard, (2) content guard is inside `if current_mode == ConversationMode.INTIMATE`, (3) skill dispatch and LLM fallback are unchanged below the gates.</manual>
  </verify>
  <done>Crisis gate runs for all modes; content guard gate runs only in intimate mode; both gates return early before LLM call; gate ordering is crisis → guard → skill dispatch → LLM; existing flow unchanged below gates.</done>
</task>

</tasks>

<verification>
Run existing test suite to confirm no regressions:
```bash
cd C:/Users/raphg/Desktop/IA/ava2 && python -m pytest backend/tests/ -x -q
```
All 28 previously passing tests must still pass. The gates do not affect secretary mode tests (no crisis phrases in test inputs) and do not affect skill dispatch tests.
</verification>

<success_criteria>
- All 28 existing tests pass (no regressions)
- chat.py parses cleanly (no syntax errors)
- Crisis gate appears before content guard in handle_message() source
- ContentGuard call is inside `if current_mode == ConversationMode.INTIMATE:` branch
- Both audit helpers have try/except wrapping DB calls
</success_criteria>

<output>
After completion, create `.planning/phases/05-intimate-mode-text-foundation/05-02-SUMMARY.md`
</output>
