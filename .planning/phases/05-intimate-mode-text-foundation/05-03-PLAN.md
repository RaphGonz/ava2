---
phase: 05-intimate-mode-text-foundation
plan: "03"
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/models/avatar.py
  - backend/app/routers/avatars.py
  - backend/app/services/session/store.py
autonomous: true
requirements:
  - PERS-01

must_haves:
  truths:
    - "PATCH /avatars/me/persona with {personality: 'dominant'} updates the avatar's personality in the DB"
    - "PATCH /avatars/me/persona returns 404 if user has no avatar"
    - "PATCH /avatars/me/persona returns 422 if personality value is not a valid PersonalityType"
    - "After PATCH /avatars/me/persona, the session avatar cache is cleared so next message uses new persona"
    - "SessionStore.clear_avatar_cache(user_id) removes the _avatar_cache attribute from the session"
  artifacts:
    - path: "backend/app/models/avatar.py"
      provides: "PersonaUpdateRequest Pydantic model with personality: PersonalityType field"
      contains: "PersonaUpdateRequest"
    - path: "backend/app/routers/avatars.py"
      provides: "PATCH /avatars/me/persona endpoint"
      contains: "patch.*me/persona|me/persona.*patch"
    - path: "backend/app/services/session/store.py"
      provides: "SessionStore.clear_avatar_cache(user_id) method"
      contains: "clear_avatar_cache"
  key_links:
    - from: "backend/app/routers/avatars.py"
      to: "backend/app/services/session/store.py"
      via: "get_session_store().clear_avatar_cache(user_id) called after DB update"
      pattern: "clear_avatar_cache"
    - from: "backend/app/routers/avatars.py"
      to: "backend/app/models/avatar.py"
      via: "PersonaUpdateRequest imported for request body validation"
      pattern: "PersonaUpdateRequest"
---

<objective>
Add persona selection and change capability: PATCH /avatars/me/persona endpoint for users to update their persona, plus session cache invalidation so changes take effect immediately.

Purpose: Satisfies PERS-01 — user can choose from preset personality personas. The PersonalityType enum already exists; this plan adds the API surface and cache invalidation.

Output: PersonaUpdateRequest model, PATCH endpoint in avatars router, clear_avatar_cache() method in SessionStore.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-intimate-mode-text-foundation/05-CONTEXT.md
@.planning/phases/05-intimate-mode-text-foundation/05-RESEARCH.md
@backend/app/models/avatar.py
@backend/app/routers/avatars.py
@backend/app/services/session/store.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: PersonaUpdateRequest Model and PATCH Endpoint</name>
  <files>
    backend/app/models/avatar.py
    backend/app/routers/avatars.py
  </files>
  <action>
**Step 1 — Add `PersonaUpdateRequest` to `backend/app/models/avatar.py`:**

Add after the existing `AvatarCreate` class:
```python
class PersonaUpdateRequest(BaseModel):
    personality: PersonalityType
```

No other changes to avatar.py. `PersonalityType` is already defined in the same file.

**Step 2 — Add PATCH endpoint to `backend/app/routers/avatars.py`:**

Add the following imports at the top (alongside existing imports):
```python
from app.models.avatar import AvatarCreate, AvatarResponse, PersonaUpdateRequest
from app.services.session.store import get_session_store
```

Add the endpoint after the existing `get_my_avatar` route:
```python
@router.patch("/me/persona")
async def update_persona(
    body: PersonaUpdateRequest,
    user=Depends(get_current_user),
    db=Depends(get_authed_supabase),
):
    """
    Update the authenticated user's avatar persona.
    Clears session avatar cache so the new persona takes effect immediately.
    """
    result = db.from_("avatars").update(
        {"personality": body.personality.value}
    ).eq("user_id", str(user.id)).execute()

    if not result.data:
        raise HTTPException(status_code=404, detail="No avatar found")

    # Invalidate session avatar cache so next message picks up the new persona
    # (per RESEARCH.md Pitfall 5: cache is never auto-invalidated on persona update)
    session_store = get_session_store()
    await session_store.clear_avatar_cache(str(user.id))

    return {"personality": body.personality.value}
```

**Important:** Use `body.personality.value` (the string "dominant" etc.) not the enum member when writing to DB — supabase-py serializes enum members inconsistently across versions.

**Per CONTEXT.md locked decision:** Persona selection is changeable in settings (not just one-time onboarding). This endpoint handles both first-time setup and subsequent changes.
  </action>
  <verify>
    <automated>cd C:/Users/raphg/Desktop/IA/ava2 && python -c "
import ast
with open('backend/app/models/avatar.py') as f:
    src = f.read()
assert 'PersonaUpdateRequest' in src, 'PersonaUpdateRequest not in avatar.py'
ast.parse(src)

with open('backend/app/routers/avatars.py') as f:
    src2 = f.read()
assert 'patch' in src2.lower() or 'PATCH' in src2, 'PATCH method not found in avatars.py'
assert 'me/persona' in src2, 'persona endpoint path not found'
assert 'clear_avatar_cache' in src2, 'cache invalidation not called in endpoint'
ast.parse(src2)
print('OK: PersonaUpdateRequest and PATCH endpoint present, files parse cleanly')
"</automated>
  </verify>
  <done>PersonaUpdateRequest is in avatar.py; PATCH /avatars/me/persona is in avatars.py; endpoint calls clear_avatar_cache after DB update; both files parse without errors.</done>
</task>

<task type="auto">
  <name>Task 2: SessionStore.clear_avatar_cache()</name>
  <files>backend/app/services/session/store.py</files>
  <action>
Add `clear_avatar_cache(user_id: str) -> None` to `SessionStore` as an async method. This method removes the `_avatar_cache` attribute from the session state so that the next `handle_message()` call re-fetches the avatar from the DB (with the updated persona).

Add after the existing `reset_session()` method:
```python
async def clear_avatar_cache(self, user_id: str) -> None:
    """Clear the avatar cache for a user so the next message re-fetches from DB.

    Called after PATCH /avatars/me/persona so persona changes take effect immediately.
    No-op if the user has no active session.
    """
    async with self._lock:
        state = self._sessions.get(user_id)
        if state is not None and hasattr(state, "_avatar_cache"):
            object.__setattr__(state, "_avatar_cache", None)
```

**Why `object.__setattr__`:** `SessionState` is a `@dataclass`. The `_avatar_cache` attribute is set dynamically via `object.__setattr__()` in chat.py (because it's not declared in the dataclass fields). The same pattern must be used to clear it.

**Why no-op on missing session:** If the user changed persona before sending any message, there is no session yet — that's fine. The next message will fetch fresh from DB naturally.

Do NOT change any other methods in store.py.
  </action>
  <verify>
    <automated>cd C:/Users/raphg/Desktop/IA/ava2 && python -c "
import ast
with open('backend/app/services/session/store.py') as f:
    src = f.read()
assert 'clear_avatar_cache' in src, 'clear_avatar_cache method missing'
ast.parse(src)

# Functional test
import asyncio
import sys
sys.path.insert(0, 'C:/Users/raphg/Desktop/IA/ava2')
sys.path.insert(0, 'C:/Users/raphg/Desktop/IA/ava2/backend')

async def test():
    from app.services.session.store import SessionStore
    from app.services.session.models import ConversationMode
    store = SessionStore()
    session = await store.get_or_create('user-1')
    # Simulate avatar cache set as in chat.py
    object.__setattr__(session, '_avatar_cache', {'name': 'Ava', 'personality': 'caring'})
    assert session._avatar_cache is not None, 'cache should be set'
    # Clear it
    await store.clear_avatar_cache('user-1')
    assert session._avatar_cache is None, 'cache should be cleared'
    # No-op on missing user
    await store.clear_avatar_cache('non-existent-user')
    print('OK: clear_avatar_cache works correctly')

asyncio.run(test())
"</automated>
  </verify>
  <done>clear_avatar_cache() is async, uses asyncio.Lock, sets _avatar_cache to None via object.__setattr__, is a no-op for non-existent sessions; store.py parses without errors.</done>
</task>

</tasks>

<verification>
Run existing test suite to confirm no regressions:
```bash
cd C:/Users/raphg/Desktop/IA/ava2 && python -m pytest backend/tests/ -x -q
```
All 28 previously passing tests must still pass.
</verification>

<success_criteria>
- PersonaUpdateRequest model in avatar.py with personality: PersonalityType field
- PATCH /avatars/me/persona returns updated personality on success, 404 if no avatar, 422 for invalid persona value
- SessionStore.clear_avatar_cache() sets _avatar_cache to None; no-op for missing sessions
- All 28 existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-intimate-mode-text-foundation/05-03-SUMMARY.md`
</output>
